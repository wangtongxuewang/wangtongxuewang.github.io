<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangtongxuewang.github.io</id>
    <title>王同学的博客</title>
    <updated>2021-11-22T11:32:04.310Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangtongxuewang.github.io"/>
    <link rel="self" href="https://wangtongxuewang.github.io/atom.xml"/>
    <subtitle>coding &amp;&amp; writing</subtitle>
    <logo>https://wangtongxuewang.github.io/images/avatar.png</logo>
    <icon>https://wangtongxuewang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 王同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[C++17结构化绑定]]></title>
        <id>https://wangtongxuewang.github.io/post/c17-jie-gou-hua-bang-ding/</id>
        <link href="https://wangtongxuewang.github.io/post/c17-jie-gou-hua-bang-ding/">
        </link>
        <updated>2021-11-22T10:58:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c17结构化绑定">C++17结构化绑定</h1>
<p>在开发中常常需要函数返回多个值，这在Python中十分容易，通过元组即可实现，示例代码如下：</p>
<pre><code class="language-python">def foo(x):
    y0 = x
    y1 = x**2
    y2 = x**3
    return (y0, y1, y2)
#end

x = 1.0
(y0, y1, y2) = foo(x)
</code></pre>
<p>然而在C++却是比较繁琐，在C++17之前，可以定义一个结构体来实现：</p>
<pre><code class="language-c++">struct ResFoo {
    double y0;
    double y1;
    double y2;
}

ResFoo foo(const double x)
{   
    ResFoo res;
    res.y0 = x;
    res.y1 = x * x;
    res.y2 = x * x * x;
    return res;
}

int main()
{
    double x = 1.0;
    ResFoo res = foo(x);
    double y0 = res.y0;
    double y1 = res.y1;
    double y2 = res.y2;
    
    // ...
    return 0; 
}
</code></pre>
<p>但是在C++17中，就可以使用结构化绑定并结合std::tuple，如同Python一样简洁地表达此意图：</p>
<pre><code class="language-c++">std::tuple&lt;double, double, double&gt; foo(const double x)
{
    return std::make_tuple&lt;double, double, double&gt;(x, x * x, x * x * x);
}

int main()
{
    double x = 1.0;
    auto [y0, y1, y2] = foo(x);
    
    // ...
    return 0;
}
</code></pre>
<p>与时俱进的C++标准让开发人员可以像使用动态语言一样编写C++代码，在开发中适当的使用这样的“语法糖”会让我们的代码更加简洁优雅。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[智能指针与QVector组合使用问题]]></title>
        <id>https://wangtongxuewang.github.io/post/zhi-neng-zhi-zhen-yu-qvector-zu-he-shi-yong-wen-ti/</id>
        <link href="https://wangtongxuewang.github.io/post/zhi-neng-zhi-zhen-yu-qvector-zu-he-shi-yong-wen-ti/">
        </link>
        <updated>2021-08-14T03:58:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="智能指针与qvector组合使用问题">智能指针与QVector组合使用问题</h1>
<h2 id="引言">引言</h2>
<p>在C++开发中，由于Qt库接口完善易用，很多桌面端程序会使用Qt各种容器库[QTL]来代替STL，关于使用QTL还是STL，萝卜白菜，各有所爱，没有绝对优劣之分；</p>
<p>但是可能由于Qt库成型较早缘故，其未能考虑到现代C++的演化，当Qt库与现代C++标准库组合使用时，有时会产生一些意想不到的问题；</p>
<h2 id="问题由来">问题由来</h2>
<p>开发中，常常需要将对象指针序列放存放在 vector 中，比如Qt库中的QVector，且为了自动内存管理，会使用智能指针 unique_ptr 来自动管理内存 [使用 unique_ptr 而不是 shared_ptr 的原因是为了更好的区分所有权]；</p>
<p>为了阐明问题实质，将实际开发中的复杂问题简化为下述简单示例，但是麻雀虽小，五脏俱全，问题关键在下述代码已经体现：</p>
<pre><code class="language-c++">#include &lt;vector&gt;
#include &lt;unique_ptr&gt;
#include &lt;QVector&gt;

using std::vector;
using std::unique_ptr;

class CTest {
    // ...
};

int main()
{
    unique_ptr&lt;CTest&gt; ptr = std::make_unique&lt;CTest&gt;();
    
    QVector&lt;unique_ptr&lt;CTest&gt;&gt; ptrVec;  // 不能通过编译
    // vector&lt;unique_ptr&lt;CTest&gt;&gt; ptrVec;  // 可以通过编译
    
    ptrVec.push_back(std:move(ptr));
    
}
</code></pre>
<p>上述代码中，使用 QVector 时并不能通过编译，若将 QVector 替换成 std::vector，便能通过编译，正常运行；</p>
<h2 id="原因分析">原因分析</h2>
<p>当使用 QVector 时，编译器在 QVector 的 reallocData 函数中报错，详见下述代码与注释 [ 代码片段来自 Qt5.12.10 中的 qvector.h ] ：</p>
<pre><code class="language-C++">template &lt;typename T&gt;
void QVector&lt;T&gt;::reallocData(const int asize, const int aalloc, QArrayData::AllocationOptions options)
{
    // ...
    
    // QVector 隐式共享机制导致 unique_ptr 不能使用;
    // 下述代码中 isShared 值为 true , 可以通过对本部分代码的调试来验证这一点;
    if (isShared || !std::is_nothrow_move_constructible&lt;T&gt;::value) {
        // we can not move the data, we need to copy construct it
        while (srcBegin != srcEnd)
            new (dst++) T(*srcBegin++);    // 主要是本行代码需要使用 复制构造 产生问题
    } else {
        while (srcBegin != srcEnd)
            new (dst++) T(std::move(*srcBegin++));
    }
    
    // ...
}
</code></pre>
<p>通过上述代码的行为可知，由于 QVector 使用隐式共享[或称写时复制(COW : copy-on-write)]机制，reallocData 函数中的 isShared 值为 true，所以需要进行复制构造操作，而 std::unique_ptr 复制构造函数无法调用，所以编译器报错，不能通过编译；</p>
<p>std::unique_ptr 相关部分代码如下 [ 代码片段来自 mingw7.3.0 中的 unique_ptr.h ] ：</p>
<pre><code class="language-C++">template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt;
class unique_ptr {
    // ...

    // Disable copy from lvalue.
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
    
    // ...
};
</code></pre>
<p>上述问题也是所有问题中我们最希望出现的一类，因为能在编译期发现问题，这比在运行时出现意想不到的错误要好很多，这也是编译型语言的优势所在；</p>
<h2 id="最佳实践">最佳实践</h2>
<p>上述问题的根源是 QVector<T> 内部设计所致：QVector<T> 使用隐式共享机制，其在reallocData 等函数实现中需要使用类的复制构造， 因此 QVector<T> 不适合存放复制构造函数无法调用的类，具体包含下述两种情况：</p>
<ul>
<li>复制构造函数 =delete；</li>
<li>复制构造函数为 private；</li>
</ul>
<p>示例代码如下：</p>
<pre><code class="language-C++">// 不能使用 QVector&lt;T&gt; 的情况1 : 赋值构造函数 被删除
class Demo1 {
public:
    Demo1() = default;
    Demo1(const Demo1&amp; rhs) = delete;
    Demo1&amp; operator=(const Demo1&amp; rhs) = delete;
    Demo1(Demo1&amp;&amp; rhs) = default;
    Demo1&amp; operator=(Demo1&amp;&amp; rhs) = default;
    ~Demo1() = default;
    
    // ...   
private:
    Obj m_obj;
};


// 不能使用 QVector&lt;T&gt; 的情况2 : 赋值构造函数 私有化
class Demo2 {
public:
    Demo2() = default;
    Demo2(Demo2&amp;&amp; rhs) = default;
    Demo2&amp; operator=(Demo2&amp;&amp; rhs) = default;
    ~Demo2() = default;

private:
    Demo2(const Demo2&amp; rhs);
    Demo2&amp; operator=(const Demo2&amp; rhs);
    
    // ...   
private:
    Obj m_obj;
};
</code></pre>
<p>Qt 中 QVector<T> 以及 QString 等库的设计中采用了隐式共享的技术以提高性能，但是有些情况下会导致类似上述问题，而 GCC 等主流编译器中标准库对 vector<T> 与 string 等的实现并不采用此技术，故不会产生以上问题，Qt 库不知后期会不会改进设计，以更好的兼容标准库；</p>
<h2 id="后记">后记</h2>
<p>后来搜索了一下，发现在 StackOverflow 中也有类似的问题：</p>
<p><a href="https://stackoverflow.com/questions/53006163/use-stdfind-on-qvectorstdunique-ptrtype"> Use std::find on QVector&lt;std::unique_ptr<Type>&gt; </a></p>
<p>其中回答也给出了简要解释，若要更为详细的介绍，可阅读本文；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[观察者模式]]></title>
        <id>https://wangtongxuewang.github.io/post/guan-cha-zhe-mo-shi/</id>
        <link href="https://wangtongxuewang.github.io/post/guan-cha-zhe-mo-shi/">
        </link>
        <updated>2021-08-07T02:18:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="观察者模式">观察者模式</h1>
<p>观察者模式是开发中常用的设计模式之一，C++Qt库中的信号槽机制就是观察者模式的典型代表，关于信号槽机制的原理与简化实现，读者可自行查阅相关资料；</p>
<p>本文仅对观察者模式做一个简要介绍：</p>
<h2 id="目的">目的</h2>
<p>实现类似 “发布-订阅” 这样的需求，且信息发布者与订阅者之间应当是松耦合，以使得发布者与订阅者独立变化，信息发布者只要广播信息而无需了解具体的信息订阅者，同时信息订阅者可以自行决定如何响应；</p>
<h2 id="概念">概念</h2>
<p>定义对象间一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都得到通知并自动更新；</p>
<h2 id="示例">示例</h2>
<p>观察者模式中信息发布者与订阅者需要松耦合设计，实现松耦合的重要方式就是多态技术，即利用类继承与虚函数重写来对不同的类约定相同的函数接口，C++示例代码如下：</p>
<pre><code class="language-C++">#ifndef OBSERVER_H
#define OBSERVER_H

#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

class AbstractObserver {   
public:    
    AbstractObserver();
    virtual ~AbstractObserver();
    
    virtual void update() {
        std::cout &lt;&lt; &quot;AbstractObserver update.&quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

class Observer1 : public AbstractObserver {    
public:  
    virtual void update() override {        
        std::cout &lt;&lt; &quot;Observer1 update.&quot; &lt;&lt; std::endl; 
        // ...
    }
};

class Observer2 : public AbstractObserver { 
public:  
    virtual void update() override {        
        std::cout &lt;&lt; &quot;Observer2 update.&quot; &lt;&lt; std::endl;    
    }
};

class Observer3 : public AbstractObserver { 
public:  
    virtual void update() override {        
        std::cout &lt;&lt; &quot;Observer3 update.&quot; &lt;&lt; std::endl;    
    }
};

class Publisher {   
public:    
    void addSubscriber(AbstractObserver * observer) { 
        auto itor = std::find(m_observers.cbegin(), m_observers.cend(), observer);
        if (itor != m_observers.cend()) {
            std::cout &lt;&lt; &quot;Add failed : duplicated add.&quot; &lt;&lt; std::endl; 
            return;
        }
        m_observers.push_back(observer); 
    }
    
    void removeSubscriber(AbstractObserver * observer) { 
        m_observers.remove(observer); 
    }
    
    void publish() {        
        for (AbstractObserver* ele : m_observers) {            
            ele-&gt;update();        
        }    
    }
    
    // ...
private:    
    std::list&lt;AbstractObserver*&gt; m_observers;
};

#endif  // OBSERVER_H
</code></pre>
<p>主函数：</p>
<pre><code class="language-C++">#include &lt;memory&gt;
#include &quot;observer.h&quot;

using std::unique_ptr;

int main() 
{    
    unique_ptr&lt;AbstractObserver&gt; observer1 = std::make_unique&lt;Observer1&gt;();  
    unique_ptr&lt;AbstractObserver&gt; observer2 = std::make_unique&lt;Observer2&gt;(); 
    unique_ptr&lt;AbstractObserver&gt; observer3 = std::make_unique&lt;Observer3&gt;(); 
    
    Publisher publisher;    
    publisher.addSubscriber(observer1.get());    
    publisher.addSubscriber(observer2.get());    
    publisher.addSubscriber(observer3.get());
    publisher.publish();
    
    publisher.removeSubscriber(observer2.get());    
    publisher.publish();
    
    // ... 
    
    return 0;
}
</code></pre>
<h2 id="参考">参考</h2>
<p>本文参考 同 本博客前述&lt;面向对象设计&gt;一文中所参考项；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[策略模式]]></title>
        <id>https://wangtongxuewang.github.io/post/ce-lue-mo-shi/</id>
        <link href="https://wangtongxuewang.github.io/post/ce-lue-mo-shi/">
        </link>
        <updated>2021-08-02T11:10:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="策略模式">策略模式</h1>
<h2 id="目的">目的</h2>
<p>在开发过程中，常使用 if-else 这样的多个分支来应对程序中的多种情况，每一个分支就是一种情况；随着需求的不断增多，分支将会迅速膨胀，造成代码块的冗长，且很有可能这样的分支远不止一处，这会给代码的维护扩展带来极大困难，策略模式可以用来解决上述问题；</p>
<h2 id="概念">概念</h2>
<p>策略模式概念：定义一系列算法，将各算法进行封装，使得它们可以相互替换；</p>
<p>策略模式让算法独立于使用它的用户而变化，当有新的算法时，代码进行扩展即可，无需过多变动；</p>
<p>一般在项目中，若发现多个 if-else 且预计还会在此增加多个 if-else 分支，那很有可能需要使用策略模式；</p>
<p>策略模式将算法行为封装为对象，以便动态选择，而不是使用显式 if-else；</p>
<h2 id="示例">示例</h2>
<h3 id="重构代码对比策略模式">重构代码对比策略模式</h3>
<p>分别列举未使用策略模式的原始代码与使用策略模式的重构后代码进行对比，两者代码分述如下；</p>
<p>原始代码：</p>
<pre><code class="language-C++">enum class GridGenMethod {    
    TransfiniteInterp,    
    EllipticEqs,
    AdvancingFrontTech,
    DelaunayTri
};

// ...


// 用户代码
void genGrid(const GridGenMethod method) 
{   
    std::cout &lt;&lt; &quot;gen grid start.&quot; &lt;&lt; std::endl; 
    
    if (method == GridGenMethod::TransfiniteInterp) {        
        std::cout &lt;&lt; &quot;TransfiniteInterp Method : &quot; &lt;&lt; std::endl;  
        // ...
    } else if (method == GridGenMethod::EllipticEqs) {        
        std::cout &lt;&lt; &quot;EllipticEqs Method : &quot; &lt;&lt; std::endl;  
        // ...   
    } else if (method == GridGenMethod::AdvancingFrontTech) {
        std::cout &lt;&lt; &quot;AdvancingFrontTech Method : &quot; &lt;&lt; std::endl;  
        // ...
    } else if (method == GridGenMethod::DelaunayTri) {
        std::cout &lt;&lt; &quot;DelaunayTri Method : &quot; &lt;&lt; std::endl;  
        // ...
    }
    
    // ...
    
    std::cout &lt;&lt; &quot;gen grid finish.&quot; &lt;&lt; std::endl;
}

int main()
{
    GridGenMethod method = GridGenMethod::EllipticEqs;
    genGrid(method);
    
    // ...
    return 0;
}

</code></pre>
<p>使用策略模式重构后代码：</p>
<pre><code class="language-C++">// 库代码
class GridGenerator {   
public:
    GridGenerator() = default;
    GridGenerator(const GridGenerator&amp; rhs) = default;
    GridGenerator&amp; operator=(const GridGenerator&amp; rhs) = default;
    GridGenerator(GridGenerator&amp;&amp; rhs) = default;
    GridGenerator&amp; operator=(GridGenerator&amp;&amp; rhs) = default;
    virtual ~GridGenerator() {
        // ...
    }
    virtual void genGrid() { 
        std::cout &lt;&lt; &quot;virtual genGrid&quot; &lt;&lt; std::endl; 
    }
private:
    //...
};

class TransfiniteInterpGenerator : public GridGenerator {    
    virtual void genGrid() override { 
        std::cout &lt;&lt; &quot;TransfiniteInterp Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
};

class EllipticEqsGenerator : public GridGenerator {    
    virtual void genGrid() override { 
        std::cout &lt;&lt; &quot;EllipticEqs Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
};

class AdvancingFrontTechGenerator : public GridGenerator {    
    virtual void genGrid() override { 
        std::cout &lt;&lt; &quot;AdvancingFrontTech Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
};

class DelaunayTriGenerator : public GridGenerator {    
    virtual void genGrid() override { 
        std::cout &lt;&lt; &quot;DelaunayTri Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
};

// 若后续有新的方法，还可以在此添加新方法的代码
// ...

// 用户代码 : 相比于原始代码，精简了很多
int main() 
{    
    std::unique_ptr&lt;GridGenerator&gt; gridGen = std::make_unique&lt;EllipticEqsGenerator&gt;();
    gridGen-&gt;genGrid();
    // ...
    
    return 0;
}
</code></pre>
<p>每增加一种方法，就增加一个继承基类的子类，重写 genGrid() 函数进行代码扩展即可；</p>
<p>观察上述代码，模板方法的代码和策略模式看起来很类似，但两者有很大区别：</p>
<ul>
<li>
<p>模板方法侧重的是将整体框架流程提供给代码使用者，代码使用者重新实现某一些具体行为即可；</p>
</li>
<li>
<p>策略模式侧重的是将算法库代码分别封装，使得它们可以相互替换，代码使用者选择其一即可；</p>
</li>
</ul>
<p>当然，两种模式均使用了C++继承与重写机制来实现各自模式；</p>
<h3 id="使用函数对象">使用函数对象</h3>
<p>还可以使用C++中函数对象来实现策略模式，与C++继承及重写类似，但是更直观易懂，代码如下：</p>
<pre><code class="language-c++">// 库代码
class TransfiniteInterpGenerator {
public:
    void operator()() { 
        std::cout &lt;&lt; &quot;TransfiniteInterp Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

class EllipticEqsGenerator {
public:
    void operator()() { 
        std::cout &lt;&lt; &quot;EllipticEqs Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

class AdvancingFrontTechGenerator {
public:
    void operator()() { 
        std::cout &lt;&lt; &quot;AdvancingFrontTech Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

class DelaunayTriGenerator { 
public:
    void operator()() { 
        std::cout &lt;&lt; &quot;DelaunayTri Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

// 若后续有新的方法，还可以在此添加新方法的代码
// ...

class GridGenerator {
public:
    enum class GridGenMethod {    
        TransfiniteInterp,    
        EllipticEqs,
        AdvancingFrontTech,
        DelaunayTri
    };
    static std::function&lt;void(void)&gt; genGrid(const GridGenMethod method) {
        return s_methodFunc.at(method);
    }
private:
    static map&lt;GridGenMethod, std::function&lt;void(void)&gt;&gt; s_methodFunc = {
        {GridGenMethod::TransfiniteInterp   , TransfiniteInterpGenerator()},
        {GridGenMethod::EllipticEqs         , EllipticEqsGenerator()},
        {GridGenMethod::AdvancingFrontTech  , AdvancingFrontTechGenerator()},
        {GridGenMethod::DelaunayTriGenerator, DelaunayTriGenerator()}
    };  
};


// 用户代码
void main() 
{  
    GridGenerator::GridGenMethod method = GridGenerator::GridGenMethod::EllipticEqs;
    std::function&lt;void(void)&gt; gridGen = GridGenerator::genGrid(method);
    gridGen();
    // ...
    
    return 0;
} 
</code></pre>
<h2 id="参考">参考</h2>
<p>本文参考 同 本博客前述&lt;面向对象设计&gt;一文中所参考项；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模板方法]]></title>
        <id>https://wangtongxuewang.github.io/post/mo-ban-fang-fa/</id>
        <link href="https://wangtongxuewang.github.io/post/mo-ban-fang-fa/">
        </link>
        <updated>2021-07-15T12:29:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="模板方法">模板方法</h1>
<p>以下介绍几种常用的设计模式，既作复习，也是在开发实践中对于设计模式的再理解；</p>
<p>顺序并不按照主要教材所列，且有些内容掺杂个人理解，并非完全正确，欢迎交流探讨；</p>
<p>首先从模板方法开始；</p>
<h2 id="目的">目的</h2>
<p>在开发中常会遇到这样的情况：自己写的库中，一个功能的流程是固定的，且大部分步骤具体实现也是固定的，但是其中某一些步骤的具体实现无法确定，是由使用该库的人进行开发，那么如何让别人使用该库时能够复用自己的代码呢？这就是模板方法的使用场景；</p>
<h2 id="概念">概念</h2>
<p>模板方法：定义一个操作中稳定不变的算法骨架，将一些步骤延迟到变化的子类中，其目的是使得子类可以复用一个算法框架；</p>
<h2 id="示例">示例</h2>
<p>在C++中，具体方法是，使用虚函数与继承实现模板方法，简单示例如下：</p>
<pre><code class="language-C++">class Solver {   
public:    
    Solver() = default;
    virtual ~Solver() = default;
    
    void solve() 
    {        
        preprocess();        
        compute();        
        postprocess();    
    }
protected:    
    virtual void compute() 
    { 
        // 常常变化
        // ...
    }
private:    
    void preprocess() 
    { 
        // 稳定的实现
        // ...
    }    
    void postprocess() 
    { 
        // 稳定的实现
        // ...
    }
    
    // ...
};


class SolverA : public Solver {
protected:     
    virtual void compute() override 
    { 
        // SolverA 的计算过程
    }
    
    // ...
};

class SolverB : public Solver {    
protected:    
    virtual void compute() override 
    { 
        // SolverB 的计算过程
    }
    
    // ...
};

class SolverC : public Solver {    
protected:    
    virtual void compute() override 
    { 
        // SolverC 的计算过程
    }
    
    // ...
};

#include &lt;vector&gt;
#include &lt;memory&gt;

using std::vector
using std::unique_ptr;

int main() 
{
    unique_ptr&lt;Solver&gt; solA = std::make_unique&lt;SolverA&gt;();
    unique_ptr&lt;Solver&gt; solB = std::make_unique&lt;SolverB&gt;();
    // ...
    
    vector&lt;unique_ptr&lt;Solver&gt;&gt; sol;
    sol.push_back(std::move(solA));
    sol.push_back(std::move(solB));
    // ...
    
    for (int i = 0; i &lt; sol.size(); ++i) {
        sol[i]-&gt;solve();
    }
    // ...
    
    return 0;
}
</code></pre>
<p>上述代码中，Solver包含：前处理，计算，后处理三个稳定的过程，其中前处理与后处理具体实现是固定的，但是“计算”因具体方法而异，所以使用模板方法，只需实现不同的计算方法即可， 而算法流程框架、前处理与后处理代码均得到复用；</p>
<h2 id="参考">参考</h2>
<p>本文参考 同 本博客前述&lt;面向对象设计&gt;一文中所参考项；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象设计]]></title>
        <id>https://wangtongxuewang.github.io/post/mian-xiang-dui-xiang-she-ji/</id>
        <link href="https://wangtongxuewang.github.io/post/mian-xiang-dui-xiang-she-ji/">
        </link>
        <updated>2021-07-03T02:22:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="面向对象设计">面向对象设计</h1>
<h2 id="目标与方法">目标与方法</h2>
<p>随着程序代码不断扩张，软件中各部分交互关系日益庞杂，其维护扩展变得异常困难，为应对此危机，面向对象设计方法得到不断发展，其要实现的目标与所用方法如下：</p>
<ul>
<li>实现目标：模块相互独立，即插即用；</li>
<li>使用方法：约定抽象接口，减少依赖；</li>
</ul>
<h2 id="特点">特点</h2>
<p>面向对象的设计有三大特点，区别于其他编程范式，分别为：</p>
<ul>
<li>封装：隐藏内部实现，达到使用接口编程而不用了解内部实现的目的；</li>
<li>继承：继承父类的属性与数据，达到代码复用的目的；</li>
<li>多态：对于同一种接口，不同的类型的对象展现不同的行为，达到接口统一的目的；</li>
</ul>
<h2 id="基本原则">基本原则</h2>
<p>为实现面向对象设计的目标，开发领域在长期理论与实践中总结出几个基本原则，不同的教材的阐述略有不同，但是表达的基本思想是一致的，最为经典的说法是将面向对象设计的这几个原则称为“SOLID”原则，名称取自这五个原则的英文缩写首字母，同时寓意在这几个原则指导下所开发软件系统的稳固性；</p>
<h3 id="单一职责原则-srp-single-responsibility-principle">单一职责原则 (SRP - Single Responsibility Principle)</h3>
<p>一个类只做一件事，一个类应该仅有一个引起它变化的原因，且其变化隐含着类的责任；</p>
<p>比如，在实际开发中，对大的类进行拆解，减少类中蕴含不同概念的成员变量与成员函数；</p>
<h3 id="开放封闭原则-ocp-open-closed-principle">开放封闭原则 (OCP - Open Closed Principle)</h3>
<p>对扩展开放，对修改关闭；即当程序需要扩展的时候，尽量不要去修改原来的代码，而应复用扩展代码，使其易于维护和升级，同时还能减少编译时间；</p>
<p>因此在开发中，要利用好继承与组合等方法，约定抽象接口，让系统中的组件相互解耦，互不影响；</p>
<h3 id="里氏替换原则-lsp-liskov-substitution-principle">里氏替换原则 (LSP - Liskov Substitution Principle)</h3>
<p>子类必须能够替换父类，即子类对象若看作是抽象父类使用时，其接口行为须与抽象语义所期望的一致，这也是开闭原则具体实现手段之一；</p>
<p>所以在实际开发中，使用继承实现约定的抽象接口，可以对同一抽象语义实现不同的具体方法；</p>
<p>这条原则也提示我们：</p>
<ul>
<li>在开发中不要仅仅为了使用一个类的属性或方法就使用继承，此时应该使用组合代替继承；</li>
<li>真正使用继承的地方应该是：一个类的概念是另一个类的概念的更上一层抽象；</li>
</ul>
<h3 id="接口隔离原则-isp-interface-segregation-principle">接口隔离原则 (ISP - Interface Segregation Principle)</h3>
<p>接口应小而完备，程序不要依赖不需要的部分；若不需要的接口太多，则会给用户程序更多困惑，且相应具体实现也会增多；当不需要的接口被修改，那么其依赖者也要被重新编译部署；</p>
<p>所以在开发中，public的抽象接口应该尽量少而精；</p>
<h3 id="依赖倒置原则-dip-dependency-inversion-principle">依赖倒置原则 (DIP - Dependency Inversion Principle)</h3>
<p>针对接口编程，程序应依赖于抽象接口而不依赖于具体实现；</p>
<p>抽象不应依赖于实现细节，而应反过来，让实现细节依赖于抽象，因为抽象接口一般是经过长期设计共同约定，是稳定的，而实现细节一般是多样且多变的；</p>
<p>所以在开发中，需精心设计抽象接口，力求抽象接口稳定，同时让具体实现依赖于(使用继承)抽象接口，当具体实现变动时，抽象接口无需变化；</p>
<h2 id="设计模式">设计模式</h2>
<p>在五大设计原则指导下，经过长期工程实践，开发领域总结出了很多实用的设计“套路”，其中最为经典与广泛使用的就是各教科书中介绍的23种设计模式；</p>
<p>随着软件开发领域的不断发展，各种设计模式还在不停的变化，但是这些设计模式所体现的设计原则是一直稳固不变的；</p>
<p>关于设计模式，篇幅所限，在本文中便不再展开；</p>
<h2 id="总结">总结</h2>
<p>我们在面向对象编程实践中，需要不断理解巩固并灵活应用面向对象的基本原则与各种设计模式，不断提升程序的可维护性与可扩展性，在此与大家共勉；</p>
<h2 id="参考">参考</h2>
<ul>
<li>GoF，设计模式--可复用面向对象软件的基础，机械工业出版社，2000年09月；</li>
<li>李建忠，C++设计模式课程；</li>
<li>程序喵大人 ，一文让你搞懂设计模式；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++的值类别]]></title>
        <id>https://wangtongxuewang.github.io/post/cde-zhi-lei-bie/</id>
        <link href="https://wangtongxuewang.github.io/post/cde-zhi-lei-bie/">
        </link>
        <updated>2021-06-21T10:40:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c的值类别">C++的值类别</h1>
<h2 id="值类别">值类别</h2>
<p>C++表达式有两种属性：类型(type)和值类别(value category)。其中类型主要区别值的大小与解读方式，此属性是大家熟知的，故不赘述，以下内容主要阐述值类别。</p>
<p>每个表达式只属于三种值类别中的一种，纯右值(prvalue)、亡值(xvalue)、左值(lvalue)；纯右值和亡值统称为右值(rvalue)，亡值和左值统称为泛左值(glvalue)；以上对于值类别的表述可能难以理解，以下进行详细解释；</p>
<p>在C++11中，值类别主要用以表达区别表达式<strong>是否拥有身份</strong>以及<strong>是否可被移动</strong>：</p>
<ul>
<li>拥有身份(泛左值)：可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的地址；</li>
<li>可被移动(右值)：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式；</li>
</ul>
<p>即拥有身份的表达式被称作泛左值表达式，可被移动的表达式被称作右值表达式，同时又有：</p>
<ul>
<li>拥有身份 且 不可被移动 的表达式被称作*左值 (lvalue)*表达式 [只属于泛左值表达式]；</li>
<li>拥有身份 且 可被移动 的表达式被称作*亡值 (xvalue)*表达式 [既属于泛左值表达式，又属于右值表达式]；</li>
<li>不拥有身份 且 可被移动 的表达式被称作*纯右值 (prvalue)*表达式 [只属于右值表达式]；</li>
<li>不拥有身份 且 不可被移动 的表达式无法使用；</li>
</ul>
<p>使用树状图直观展示如下：<br>
[需复制下述文字并使用typora打开]</p>
<pre><code class="language-mermaid">graph TB
A(表达式)
B(泛左值)
C(右值)
D(左值)
E(亡值)
F(纯右值)

A--&gt;B
A--&gt;C
B--&gt;D
B--&gt;E
C--&gt;E
C--&gt;F
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://wangtongxuewang.github.io/post-images/1624275021149.jpg" alt="" loading="lazy"></figure>
<h2 id="移动语义">移动语义</h2>
<p>在C++11中引入新的值类别的概念，其中重要目的就是应用移动语义，以此减少很多不必要的拷贝，从而大幅度提升性能；</p>
<p>实现“移动”主要是依靠std::move(), 其主要功能其实并不是真正的移动，而是将表达式值类别强制转换为右值型别，其具体实现在C++STL中如下所示 [ 代码片段来自 MinGW7.3.0 中的 move.h ]</p>
<pre><code class="language-c++">/**
  *  @brief  Convert a value to an rvalue.
  *  @param  __t  A thing of arbitrary type.
  *  @return The parameter cast to an rvalue-reference to allow moving it.
  */
template&lt;typename _Tp&gt;
constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;
move(_Tp&amp;&amp; __t) noexcept
{ 
    return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); 
}
</code></pre>
<h2 id="应用举例">应用举例</h2>
<p>下述例子并不能体现 std::move() 的优点，只是作为一个简单例子进行说明：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;memory&gt;

using std::cout;
using std::endl;
using std::unique_ptr;

class Demo {
public:
    Demo() = default;
    Demo(const Demo&amp; rhs) = default;
    Demo(Demo&amp;&amp; rhs) = default;
    Demo&amp; operator=(const Demo&amp; rhs) = default;
    Demo&amp; operator=(Demo&amp;&amp; rhs) = default;
    ~Demo() = default;
private:
    int m_a = 1;
    // ...
};


int main()
{
    unique_ptr&lt;Demo&gt; ptrDemo = std::make_unique&lt;Demo&gt;();

    cout &lt;&lt; &quot;ptrDemo : &quot; &lt;&lt; ptrDemo.get() &lt;&lt; endl;

    // unique_ptr不支持拷贝构造与拷贝赋值操作
    unique_ptr&lt;Demo&gt; ptrDemo2 = std::move(ptrDemo);
    assert(ptrDemo == nullptr);

    cout &lt;&lt; &quot;ptrDemo : &quot; &lt;&lt; ptrDemo.get() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptrDemo2 : &quot; &lt;&lt; ptrDemo2.get() &lt;&lt; endl;

    // ...

    return 0;
}

</code></pre>
<p>终端输出：</p>
<pre><code class="language-c++">// console output : 
ptrDemo : 0x1304b68
ptrDemo : 0
ptrDemo2 : 0x1304b68
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://www.cnblogs.com/zhao-zongsheng/p/value_categories_and_move_semantics.html">C++11的value category(值类别)以及move semantics(移动语义)</a></p>
<p><a href="https://zh.cppreference.com/w/cpp/language/value_category">cppreference - value_category</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[运行时类型识别]]></title>
        <id>https://wangtongxuewang.github.io/post/yun-xing-shi-lei-xing-shi-bie/</id>
        <link href="https://wangtongxuewang.github.io/post/yun-xing-shi-lei-xing-shi-bie/">
        </link>
        <updated>2021-06-13T09:26:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="运行时类型识别">运行时类型识别</h1>
<p>运行时类型识别(RTTI)主要作用是获得指针及引用变量的实际类型, 其主要操作有两种, 分别是 获取实际类型 与 安全类型转换；</p>
<h2 id="获取实际类型">获取实际类型</h2>
<p>获取实际类型主要依靠:  typeid 关键字 与 type_info 类, 示例代码如下:</p>
<p>类代码:</p>
<pre><code class="language-c++">// demo.h
class Demo {
public:
    Demo() = default;
    virtual ~Demo() = default;

    virtual void disp()  {cout &lt;&lt; &quot;Demo&quot; &lt;&lt; endl;}

    inline double dispA() {return m_a;}
private:
    double m_a = 10.0;
};


class DemoDerived : public Demo {
public:
    DemoDerived() = default;
    ~DemoDerived() = default;

    virtual void disp() override {cout &lt;&lt; &quot;DemoDeriv&quot; &lt;&lt; endl;}

    inline double dispB() {return m_b;}
private:
    double m_b = 8.0;
};
</code></pre>
<p>主函数:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

#include &quot;demo.h&quot;

using std::cout;
using std::endl;
using std::type_info;


int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new DemoDerived();

    const type_info&amp; type1 = typeid (*demo1);
    const type_info&amp; type2 = typeid (*demo2);

    cout &lt;&lt; type1.name() &lt;&lt; endl;
    cout &lt;&lt; type2.name() &lt;&lt; endl;

    delete demo1;
    delete demo2;

    return 0;
}
</code></pre>
<p>终端输出:</p>
<pre><code class="language-c++">// console output : 
4Demo
11DemoDerived
</code></pre>
<p>不同编译器可能输出略微不同, 但是仍可看到两个指针所指向的实际类型分别为 Demo 与 DemoDerived, 其中数字表示类型名称的字符长度；</p>
<h2 id="安全类型转换">安全类型转换</h2>
<p>在基类与继承类之间进行安全类型转换主要依靠 dynamic_cast&lt;&gt;() 操作, 示例代码如下；</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

#include &quot;demo.h&quot;

using std::cout;
using std::endl;
using std::type_info;


int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new DemoDerived();

    DemoDerived* demoCast1 = dynamic_cast&lt;DemoDerived*&gt;(demo1);
    DemoDerived* demoCast2 = dynamic_cast&lt;DemoDerived*&gt;(demo2);

    cout &lt;&lt; &quot;demoCast1 addr = &quot; &lt;&lt; demoCast1 &lt;&lt; endl;
    cout &lt;&lt; &quot;demoCast2 addr = &quot; &lt;&lt; demoCast2 &lt;&lt; endl;

    delete demo1;
    delete demo2;

    return 0;
}
</code></pre>
<p>上述代码终端输出:</p>
<pre><code class="language-c++">// console output : 
demoCast1 addr = 0
demoCast2 addr = 0x55555556aed0
</code></pre>
<p>其中, demo2 的实际类型是 DemoDerived, 所以动态类型转换成功, demoCast2是有效地址；demo1 的实际类型 Demo, 所以动态类型转换失败, demoCast1 地址为 0, 是无效地址, 表示了这种转换是不正确的, 这正是动态类型转换的安全性所在；</p>
<p>而静态类型转换 static_cast 不会检查类型转换之间的安全性, 反而会引起一些潜在危险,且难以排查, 示例代码如下:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

#include &quot;demo.h&quot;

using std::cout;
using std::endl;
using std::type_info;

int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new DemoDerived();

    DemoDerived* ptrDemoError = static_cast&lt;DemoDerived *&gt;(demo1);

    cout &lt;&lt; &quot;ptrDemoError addr = &quot; &lt;&lt; ptrDemoError &lt;&lt; endl;

    cout &lt;&lt; ptrDemoError-&gt;dispA() &lt;&lt; endl;
    cout &lt;&lt; ptrDemoError-&gt;dispB() &lt;&lt; endl;

    delete demo1;
    delete demo2;

    return 0;
}
</code></pre>
<p>上述代码终端输出为:</p>
<pre><code class="language-c++">// console output : 
ptrDemoError addr = 0x55555556aeb0
10
0
</code></pre>
<p>虽然上述代码中的类型转换是不正确的, 但是静态类型转换仍然能够获得demo1的地址, 而后其错误地使用了DemoDerived中的dispB(), 给出了错误的结果；这种错误排查难度远远大于程序意外终止等明显的问题；</p>
<p>所以, 在基类与继承类之间的转换中尽量只使用 dynamic_cast, 不要使用C风格的强制类型转换 与 static_cast 等不安全的类型转换, 除非自己明确知道这种类型的转换一定是正确的, 否则产生错误可能非常难以排查；</p>
<h2 id="总结">总结</h2>
<p>运行时类型识别RTTI虽然会降低程序性能, 但是适当使用提升了程序的安全性, 对编码起到事半功倍的效果；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 std::unique_ptr 的思考]]></title>
        <id>https://wangtongxuewang.github.io/post/guan-yu-stdunique_ptr-de-si-kao/</id>
        <link href="https://wangtongxuewang.github.io/post/guan-yu-stdunique_ptr-de-si-kao/">
        </link>
        <updated>2021-05-31T12:11:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于-stdunique_ptr-的思考">关于 std::unique_ptr 的思考</h1>
<p>std::unique_ptr 表示独占所有权的智能指针，正常情况下，此智能指针管理内存的获取与释放，而普通指针仅负责使用内存；</p>
<h2 id="禁止拷贝">禁止拷贝</h2>
<p>由于 std::unique_ptr 表示独占的含义，所以其是不支持拷贝的，在C++标准库中，unique_ptr 禁止拷贝的实现如下 [ 代码片段来自 MinGW5.3.0 中的 unique_ptr.h ]：</p>
<pre><code class="language-c++">template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt;
class unique_ptr {
public:
    // ...
    // Disable copy from lvalue.
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
    // ...
};
</code></pre>
<p>由代码可知，禁止拷贝的实现中采用了C++11的 delete 关键字；而在C++11之前，若要实现禁止拷贝的功能，传统方法是将拷贝构造与赋值运算符私有化，这样是非常不直观的，示例代码如下：</p>
<pre><code class="language-C++">// C++98/03风格的禁止拷贝实现方式
class Demo {
public:
    Demo();
    // ...
private:
    Demo(const Demo&amp; rhs);
    Demo&amp; operator=(const Demo&amp; rhs);
    // ...
}
</code></pre>
<h2 id="函数返回">函数返回</h2>
<p>在C++标准中，std::unique_ptr 是支持函数返回的，最为典型的就是 std::make_unique，其实现代码如下 [ 代码片段来自 MinGW5.3.0 中的 unique_ptr.h ]：</p>
<pre><code class="language-c++">/// std::make_unique for single objects
template&lt;typename _Tp, typename... _Args&gt;
inline typename _MakeUniq&lt;_Tp&gt;::__single_object
make_unique(_Args&amp;&amp;... __args)
{
    return unique_ptr&lt;_Tp&gt;(new _Tp(std::forward&lt;_Args&gt;(__args)...)); 
}
</code></pre>
<p>既然 std::unique_ptr 不支持拷贝，那么为什么其可以进行函数返回呢？这似乎与不支持拷贝是矛盾的；</p>
<p>我们知道，在函数返回中，返回值优化RVO(其在C++17中进入标准)可以让对象直接在函数调用处生成， 而不产生多余的临时对象，从而绕过拷贝/移动构造操作；</p>
<p>因此，std::unique_ptr 的能够函数返回的重要机制是返回值优化RVO绕过了拷贝/移动构造，使其能够函数返回；</p>
<h2 id="开发启示">开发启示</h2>
<p>如上所述，C++标准库在实现中大量应用了C++11/14/17等现代特性，如  =delete，RVO，等；</p>
<p>所以，在开发实践中，我们亦应编写现代C++风格的代码，与时俱进，才能让程序更优雅，更具维护性；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++复制省略]]></title>
        <id>https://wangtongxuewang.github.io/post/cfu-zhi-sheng-lue/</id>
        <link href="https://wangtongxuewang.github.io/post/cfu-zhi-sheng-lue/">
        </link>
        <updated>2021-05-17T12:45:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c-复制省略">C++ 复制省略</h1>
<h2 id="代码示例">代码示例</h2>
<p>在C++中，若要在函数中传递一个占用较多空间的对象到函数体外，一般做法是在函数体外定义变量，并传递指针或引用到函数中，示例代码如下：</p>
<pre><code class="language-c++">// demo.h
class Demo {
public:
    Demo() {std::cout &lt;&lt; &quot;Demo()&quot; &lt;&lt; std::endl;}
    Demo(const Demo&amp; rhs) {std::cout &lt;&lt; &quot;Demo(const Demo&amp; rhs)&quot; &lt;&lt; std::endl;}
    Demo&amp; operator=(const Demo&amp; rhs) {std::cout &lt;&lt; &quot;Demo&amp; operator=(const Demo&amp; rhs)&quot; &lt;&lt; std::endl;}
    Demo(Demo&amp;&amp; rhs) {std::cout &lt;&lt; &quot;Demo(Demo&amp;&amp; rhs)&quot; &lt;&lt; std::endl;}
    Demo&amp; operator=(Demo&amp;&amp; rhs) {std::cout &lt;&lt; &quot;Demo&amp; operator=(Demo&amp;&amp; rhs)&quot; &lt;&lt; std::endl;}
    ~Demo() {std::cout &lt;&lt; &quot;~Demo()&quot; &lt;&lt; std::endl;}
    
    void update();

private:
    int m_a = 10;
    std::vector&lt;double&gt; m_x = {1.2, 2.4};
};
</code></pre>
<pre><code class="language-c++">#include &quot;demo.h&quot;

void func(Demo&amp; demo)
{
    demo.update();
    // do other things to demo.
}

int main() 
{
    Demo demo;
    func(demo);
    
    // ...
    
    return 0;
}
</code></pre>
<p>上述方法无疑是正确的，且能保证性能，但是较为繁琐，而且存在一些潜在隐患；其实，在函数中直接返回一个对象更能反映上述代码的语义，同时更简洁优雅，示例代码如下：</p>
<pre><code class="language-c++">#include &quot;demo.h&quot;

Demo func()
{
    Demo demo
        
    demo.update(a);
    // do other things to demo.
    
    return demo;
}

int main() 
{
    Demo demo = func();
    
    // ...
    
    return 0;
}
</code></pre>
<p>然而由于C++的值语义原因，在第二种方法中，当在函数中返回一个对象时，产生了多余的复制构造与析构操作，代价比较昂贵，所以要想性能优先，那么使用第一种方法更好；</p>
<p>但是，当我们将第二种方法的代码进行编译时，却意外地发现程序只进行了一次构造与析构，和第一种方法性能是一致的，终端输出如下：</p>
<pre><code class="language-c++">// console : 
Demo()
~Demo()
</code></pre>
<p>上述令我们感到惊讶的现象背后就是：编译器的<strong>复制省略(copy-elison)/返回值优化(rvo/nrvo)技术</strong>，此技术已经是C++标准(C++17)的一部分，所以此代码的性能在任何主流编译器的默认选项中都能得到保证；</p>
<p>若想要关闭此功能，以观察编译器原始的表现，可在CMakeLists.txt中进行如下设置：</p>
<pre><code>set(CMAKE_C_FLAGS   &quot;-O0 -Wall -fno-elide-constructors&quot;)
set(CMAKE_CXX_FLAGS &quot;-O0 -Wall -fno-elide-constructors&quot;)
</code></pre>
<p>重新编译后，终端输出如下：</p>
<pre><code class="language-c++">// console : 
Demo()
Demo(Demo&amp;&amp; rhs)
~Demo()
Demo(Demo&amp;&amp; rhs)
~Demo()
~Demo()
</code></pre>
<p>上述结果符合我们预期，产生了两次额外移动构造与析构操作，第一次是函数返回一个对象到临时空间中，另一次是临时对象赋值给目标变量；</p>
<h2 id="最佳实践">最佳实践</h2>
<p>现代C++推荐我们在函数中直接返回一个对象，这可让代码更为简洁，而且其性能由C++标准保证，所以在编写新代码时，尽量使用现代C++推荐的方式；</p>
]]></content>
    </entry>
</feed>