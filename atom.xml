<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangtongxuewang.github.io</id>
    <title>王同学的博客</title>
    <updated>2021-04-13T07:25:42.389Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangtongxuewang.github.io"/>
    <link rel="self" href="https://wangtongxuewang.github.io/atom.xml"/>
    <subtitle>&lt;font size=&quot;10&quot;&gt;sharing&lt;/font&gt;</subtitle>
    <logo>https://wangtongxuewang.github.io/images/avatar.png</logo>
    <icon>https://wangtongxuewang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 王同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[C++类内初始化]]></title>
        <id>https://wangtongxuewang.github.io/post/clei-nei-chu-shi-hua/</id>
        <link href="https://wangtongxuewang.github.io/post/clei-nei-chu-shi-hua/">
        </link>
        <updated>2021-04-13T00:38:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c类内初始化">C++类内初始化</h1>
<h2 id="引言">引言</h2>
<p>当成员变量参数较多，很可能在构造函数中忘记初始化某些成员变量，当需要访问某些变量时可能会产生意想不到的行为，故需一种简明的方式避免此问题的发生；</p>
<h2 id="类内初始化">类内初始化</h2>
<p>对于上述问题，可使用C++11中特性——类内初始化，防止遗漏某些变量的初始化，示例代码如下：</p>
<pre><code class="language-C++">class Demo {
public:
    Demo() = default;
    Demo(const int a, const double b);
    ~Demo() = default;
    // ...
private:
    int     m_a = 1;
    double  m_b = 2.0;
    X*      m_c = nullptr;
    std::vector&lt;int&gt; m_d = {1, 2, 3};
};

Demo::Demo(const int a, const double b) : m_a(a), m_b(b)
{
    // do nothing
}

// ...

int main()
{
    Demo demo1;  // 此时各成员变量已经赋上相应初值
    Demo demo2(1, 2.0);

    // do something

    return 0;
}
</code></pre>
<h2 id="结论">结论</h2>
<p>当类中成员变量较多时，可适当使用类内初始化来避免遗漏某些成员变量初始化值；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++中的explicit]]></title>
        <id>https://wangtongxuewang.github.io/post/czhong-de-explicit/</id>
        <link href="https://wangtongxuewang.github.io/post/czhong-de-explicit/">
        </link>
        <updated>2021-04-12T11:33:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c中的explicit">C++中的explicit</h1>
<h2 id="引言">引言</h2>
<p>在C++开发中，常会因为各种原因无意中编写出如下代码：</p>
<pre><code class="language-c++">class Demo {
public:
    Demo() = default;
    Demo(const int a);
    Demo(const double b, const double c=2.5, const double d=3.5);
    ~Demo() = default;
    // ...
private:
    int m_a;
    double m_b;
};

int main()
{
    Demo demo = 10;  // 编译通过，但这不是我们想要的行为
    
    // ...
    return 0;
}
</code></pre>
<p>上述代码编译通过，即编译器允许这种操作，这实际上是调用了构造函数 Demo(const int a) 进行了隐式转换，但此操作很可能是开发人员不希望发生的，程序有可能会在运行中发生意想不到的错误，所以需要一种机制禁止这种隐式转换；</p>
<h2 id="方法">方法</h2>
<p>C++提供了在构造函数中添加 explicit 关键字来防止上述问题的发生，在 Qt 库中，经常可以看到此种习惯，这减少了程序隐患，值得我们学习参考；</p>
<p>上述代码改进后，如下所示：</p>
<pre><code class="language-c++">class Demo {
public:
    Demo() = default;
    explicit Demo(const int a);
    explicit Demo(const double b, const double c=2.5, const double d=3.5);
    ~Demo() = default;
    void update();
    // ...
private:
    int m_a;
    double m_b;
};

int main()
{
    Demo demo = 10;  // 编译不通过，符合我们对程序行为的预期
    
    // ...
    return 0;
}
</code></pre>
<h2 id="结论">结论</h2>
<p>最佳实践：在类构造函数中，只要能使用一个参数的，均加上 explicit 关键字以防止隐式转换；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++类成员函数指针获取]]></title>
        <id>https://wangtongxuewang.github.io/post/clei-cheng-yuan-han-shu-zhi-zhen-huo-qu/</id>
        <link href="https://wangtongxuewang.github.io/post/clei-cheng-yuan-han-shu-zhi-zhen-huo-qu/">
        </link>
        <updated>2021-04-11T03:51:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c类成员函数指针获取">C++类成员函数指针获取</h1>
<p>在C++开发中，我们经常会遇到需要获取类成员函数中的指针，这个是大家都比较熟悉的；</p>
<p>那么如果类成员函数是重载的，应如何获取指定类成员函数指针呢，示例C++代码如下：</p>
<pre><code class="language-c++">class GLWidget {
public:
    void update(int a, int b);
    void updata();
private:
    // ...
};


#include &lt;QObject&gt;
#include &lt;QTimer&gt;

int main()
{
    const int updateMilliSec = 10;
    
    QTimer timer;
    timer.start(updateMilliSec);
    
    GLWidget glWidget;
    
    typedef void (GLWidget::*PtrTypeUpdate1)(int, int);
    using PtrTypeUpdate2 = void (GLWidget::*)(void);
    
    PtrTypeUpdate1 ptrUpdate1 = static_cast&lt;PtrTypeUpdate1&gt;(&amp;GLWidget::update);
    PtrTypeUpdate2 ptrUpdate2 = static_cast&lt;PtrTypeUpdate2&gt;(&amp;GLWidget::update);
    
    QObject::connect(&amp;timer, &amp;QTimer::timeout, &amp;glWidget, ptrUpdate1); 
    
    // ...
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>