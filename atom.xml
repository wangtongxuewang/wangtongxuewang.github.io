<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangtongxuewang.github.io</id>
    <title>王同学的博客</title>
    <updated>2021-12-04T03:54:13.167Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangtongxuewang.github.io"/>
    <link rel="self" href="https://wangtongxuewang.github.io/atom.xml"/>
    <subtitle>coding &amp;&amp; writing</subtitle>
    <logo>https://wangtongxuewang.github.io/images/avatar.png</logo>
    <icon>https://wangtongxuewang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 王同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[工厂模式]]></title>
        <id>https://wangtongxuewang.github.io/post/gong-han-mo-shi/</id>
        <link href="https://wangtongxuewang.github.io/post/gong-han-mo-shi/">
        </link>
        <updated>2021-12-04T03:25:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="工厂模式">工厂模式</h1>
<h2 id="概念">概念</h2>
<p>工厂模式是创建型模式中的一种，其目的是：隐藏各个对象创建的具体实现细节，仅通过抽象接口进行模块之间的调用；</p>
<p>工厂模式的优点是：隔离了两个模块之间的源码依赖关系，防止了两个模块越过自己的边界而侵入对方，从而两个模块可以独立开发、独立编译、独立部署，互不影响；</p>
<p>若整个软件代码能够确定永远是单体程序且不关心编译时间，那么工厂模式的作用并不会特别明显，</p>
<p>工厂模式的实现关键是，创建纯虚接口，并通过多态，将创建对象的工作延迟到子类执行，由子类确定实例化的对象；</p>
<p>工厂模式大致有：简单工厂、工厂方法、抽象工厂三种，现分述如下；</p>
<h2 id="简单工厂">简单工厂</h2>
<p>简单工厂模式，顾名思义，是工厂模式中较为简单的一个，没有其他多余的东西，朴素地展示了工厂模式中最精髓的观点：隐藏类创建实现细节，实现类使用者与提供者的源码隔离；</p>
<p>为了说明简单工厂模式，使用生产自行车的场景来说明，自行车有美利达、捷安特与喜德盛三个产品类，使用工厂类来创建这三种产品，示例代码如下所示；</p>
<p>产品类代码由：产品纯虚接口类、继承了纯虚接口的三种品牌的自行车产品类所组成，具体如下：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  Bicycle.h
 */
class Bicycle {
public:
	virtual ~Bicycle() {}
	virtual void show() = 0;
};


//  ----------------------------------------------------------------------------
/**
 * @file  MeridaBicycle.h 
 */
#include &quot;Bicycle.h&quot;
class MeridaBicycle : public Bicycle {
public:
	void show() { std::cout &lt;&lt; &quot;product : MeridaBicycle.&quot; &lt;&lt; endl; }
};


//  ----------------------------------------------------------------------------
/**
 * @file  GiantBicycle.h 
 */
#include &quot;Bicycle.h&quot;
class GiantBicycle : public Bicycle {
public:
	void show() { std::cout &lt;&lt; &quot;product : GiantBicycle.&quot; &lt;&lt; std::endl; }
};
 

//  ----------------------------------------------------------------------------
/**
 * @file  XdsBicycle.h 
 */
#include &quot;Bicycle.h&quot;
class XdsBicycle : public Bicycle {
public:
	void show() { std::cout &lt;&lt; &quot;product : XdsBicycle.&quot; &lt;&lt; std::endl; }
};
</code></pre>
<p>工厂类代码的头文件中是不包含产品类的代码的，只有实现文件中才包含产品类代码，具体如下：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  factory.h
 */
class Bicycle;

enum ProductType {
    Merida,
    Giant,
    Xds
};

class Factory {
public:
	Bicycle * createBicycle(const ProductType type);
};


//  ----------------------------------------------------------------------------
/**
 * @file  factory.cpp
 */
#include &quot;factory.h&quot;
#include &quot;MeridaBicycle.h&quot;
#include &quot;GiantBicycle.h&quot;
#include &quot;XdsBicycle.h&quot;
Bicycle* Factory::creatBicycle(const ProductType type)
{
    switch(type) {
	case Merida: 
		return new MeridaBicycle();
	case Giant:
		return new GiantBicyle();
	case Xds:
		return new XdsBicycle();
	default:
        return nullptr;
    }
}
</code></pre>
<p>使用产品类的代码中只需要包含工厂类的头文件即可，完全没有引入产品类的源码，具体如下：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  main.cpp
 */
#include &quot;factory.h&quot;
int main()
{
    Factory builder;
    Bicycle* pMerida = builder.createBicycle(Merida);
    Bicycle* pGiant = builder.createBicycle(Giant);
    Bicycle* pXds = builder.createBicycle(Xds);
    
    pMerida-&gt;show();
    pGiant-&gt;show();
    pXds-&gt;show();
    
    delete pMerida;
    delete pGiant;
    delete pXds;
    
    return 0;
}
</code></pre>
<p>通过上述代码可知，使用简单工厂模式后，调用者不会引入对于产品类的源码的依赖，完全不知道产品类的具体实现细节，只需使用工厂类的抽象接口即可，这样就实现了不同模块之间的源码依赖；</p>
<p>但是简单工厂模式有一个缺点，当需要增加新的产品类时，要修改工厂类的源码，这违背了开闭原则，而下述的工厂方法改进了这一点；</p>
<h2 id="工厂方法">工厂方法</h2>
<p>针对简单工厂的缺陷，可将工厂类改为纯虚接口，并添加继承于纯虚接口类的具体工厂类，让产品类的创建延迟到工厂子类中实现；</p>
<p>当增加新的产品类时，同时添加一个继承于纯虚工厂类的子工厂类来实现新产品类的创建，这样就不用修改原工厂类的源码，虽然增加了部分类定义的代码，但是换来了开闭原则，这还是值得的；</p>
<p>产品类的代码与简单工厂是一样的，示例代码如下：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  Bicycle.h
 */
class Bicycle {
public:
	virtual ~Bicycle() {}
	virtual void show() = 0;
};


//  ----------------------------------------------------------------------------
/**
 * @file  MeridaBicycle.h 
 */
#include &quot;Bicycle.h&quot;
class MeridaBicycle : public Bicycle {
public:
	void show() { std::cout &lt;&lt; &quot;product : MeridaBicycle.&quot; &lt;&lt; endl; }
};


//  ----------------------------------------------------------------------------
/**
 * @file  GiantBicycle.h 
 */
#include &quot;Bicycle.h&quot;
class GiantBicycle : public Bicycle {
public:
	void show() { std::cout &lt;&lt; &quot;product : GiantBicycle.&quot; &lt;&lt; std::endl; }
};
 

//  ----------------------------------------------------------------------------
/**
 * @file  XdsBicycle.h 
 */
#include &quot;Bicycle.h&quot;
class XdsBicycle : public Bicycle {
public:
	void show() { std::cout &lt;&lt; &quot;product : XdsBicycle.&quot; &lt;&lt; std::endl; }
};
</code></pre>
<p>不同的是工厂类的实现代码，需要创建纯虚工厂类，并让工厂子类继承于它：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  Factory.h 
 */
class Bicycle;
class Factory {
public:
    virtual ~Factory() {}
    virtual Bicycle* createBicycle() = 0;
};


//  ----------------------------------------------------------------------------
/**
 * @file  MeridaFactory.h 
 */
#include &quot;Factory.h&quot;
class MeridaFactory : public Factory {
public:
	Bicycle * createBicycle() override;
};

//  ----------------------------------------------------------------------------
/**
 * @file  MeridaFactory.cpp
 */
#include &quot;MeridaFactory.h&quot;
Bicycle* MeridaFactory::createBicycle()
{
    return new MeridaBicycle();
}



//  ----------------------------------------------------------------------------
/**
 * @file  GiantFactory.h 
 */
#include &quot;Factory.h&quot;
class GiantFactory : public Factory {
public:
	Bicycle * createBicyle() override;
};

//  ----------------------------------------------------------------------------
/**
 * @file  GiantFactory.cpp
 */
#include &quot;GiantFactory.h&quot;
Bicycle* GiantFactory::createBicyle()
{
    return new GiantBicycle();
}


//  ----------------------------------------------------------------------------
/**
 * @file  XdsFactory.h 
 */
#include &quot;Factory.h&quot;
class XdsFactory : public Factory {
public:
	Bicycle * createBicyle() override;
};

//  ----------------------------------------------------------------------------
/**
 * @file  XdsFactory.cpp 
 */
#include &quot;XdsFactory.h&quot;
Bicycle* XdsFactory::createBicycle()
{
    return new XdsBicycle();
}
</code></pre>
<p>调用工厂类的代码如下：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  main.cpp 
 */
#include &quot;MeridaFactory.h&quot;
#include &quot;GiantFactory.h&quot;
#include &quot;XdsFactory.h&quot;
int main()
{
    MeridaFactory meridaBuilder;
    GiantFactory giantBuilder;
    XdsFactory xdsBuilder;
    
    Bicycle* pMerida = meridaBuilder.createBicycle();
    Bicycle* pGiant = giantBuilder.createBicycle();
    Bicycle* pXds = xdsBuilder.createBicycle();
    
    pMerida-&gt;show();
    pGiant-&gt;show();
    pXds-&gt;show();
    
    delete pMerida;
    delete pGiant;
    delete pXds;
    
    return 0;
}
</code></pre>
<p>从上述代码可看出，相对于简单工厂，当有新的产品时，无需修改抽象工厂类代码，只要添加继承于抽象工厂类的子类即可，遵循了开闭原则；</p>
<p>综上，工厂方法成功实现了两大功能：</p>
<ul>
<li>隐藏产品类创建细节，遵循了依赖倒置原则；</li>
<li>不修改工厂类源码的情况下添加新产品类，遵循了开闭原则；</li>
</ul>
<h2 id="抽象工厂">抽象工厂</h2>
<p>有时在开发中还会遇到一个抽象工厂类需要创建多种有一定关联性的产品类的需求，由于多种产品类有一定关联性，所以放在一个抽象工厂类中创建更为合适；</p>
<p>这时只需要在工厂方法的基础上作简单的扩展，提供更多创建产品类的接口即可，即衍生版的工厂方法，称之为抽象工厂；</p>
<p>若无需创建多种对象，则无需使用抽象工厂，使用工厂方法即可；</p>
<p>仍以生产自行车的厂商为例，若这三个品牌要添加电动车生产线，则产品类的代码需要添加电动车抽象产品类和三个子类，而自行车产品类代码不变，具体如下：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  Bicycle.h
 */
class Bicycle {
public:
	virtual ~Bicycle() {}
	virtual void show() = 0;
};


//  ----------------------------------------------------------------------------
/**
 * @file  MeridaBicycle.h 
 */
#include &quot;Bicycle.h&quot;
class MeridaBicycle : public Bicycle {
public:
	void show() { std::cout &lt;&lt; &quot;product : MeridaBicycle.&quot; &lt;&lt; endl; }
};


//  ----------------------------------------------------------------------------
/**
 * @file  GiantBicycle.h 
 */
#include &quot;Bicycle.h&quot;
class GiantBicycle : public Bicycle {
public:
	void show() { std::cout &lt;&lt; &quot;product : GiantBicycle.&quot; &lt;&lt; std::endl; }
};


//  ----------------------------------------------------------------------------
/**
 * @file  XdsBicycle.h 
 */
#include &quot;Bicycle.h&quot;
class XdsBicycle : public Bicycle {
public:
	void show() { std::cout &lt;&lt; &quot;product : XdsBicycle.&quot; &lt;&lt; std::endl; }
};
</code></pre>
<p>下述代码为新添加的电动车产品类代码：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  Ebike.h 
 */
class Ebike {
public:
	virtual ~Ebike() {}
	virtual void show() = 0;
};
 
//  ----------------------------------------------------------------------------
/**
 * @file  MeridaEbike.h 
 */
#include &quot;Ebike.h&quot;
class MeridaEbike : public Ebike {
public:
	void show() { std::cout &lt;&lt; &quot;product : MeridaEbike.&quot; &lt;&lt; std::endl; }
};
 
//  ----------------------------------------------------------------------------
/**
 * @file  GiantEbike.h 
 */
#include &quot;Ebike.h&quot;
class GiantEbike : public Ebike {
public:
	void show() { std::cout &lt;&lt; &quot;product : GiantEbike.&quot; &lt;&lt; std::endl; }
};
 
//  ----------------------------------------------------------------------------
/**
 * @file  XdsEbike.h 
 */
#include &quot;Ebike.h&quot;
class XdsEbike : public Ebike {
public:
	void show() { std::cout &lt;&lt; &quot;product : XdsEbike.&quot; &lt;&lt; std::endl; }
};
</code></pre>
<p>抽象工厂类中需要添加创建电动车的接口，各个子类也要同步添加并负责实现创建电动车产品类；</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  Factory.h 
 */
class Factory {
public:
    virtual Bicycle * createBicyle() = 0;
    virtual Ebike * createEbike() = 0;
    virtual ~Factory() {}
};



//  ----------------------------------------------------------------------------
/**
 * @file  MeridaFactory.h 
 */
#include &quot;Factory.h&quot;
class MeridaFactory : public Factory {
public:
    Bicycle * createBicyle() override;
    Ebike * createEbike() override;
};

//  ----------------------------------------------------------------------------
/**
 * @file  MeridaFactory.cpp
 */
#include &quot;MeridaBicycle.h&quot;
#include &quot;MeridaEbike.h&quot;
Bicycle* MeridaFactory::createBicyle()
{
    return new MeridaBicyle();
}

Ebike * MeridaFactory::createEbike()
{
    return new MeridaEbike();
}




//  ----------------------------------------------------------------------------
/**
 * @file  GiantFactory.h 
 */
#include &quot;Factory.h&quot;
class GiantFactory : public Factory {
public:
    Bicycle * createBicyle() override;
    Ebike * createEbike() override;
};

//  ----------------------------------------------------------------------------
/**
 * @file  GiantFactory.cpp
 */
#include &quot;GiantBicycle.h&quot;
#include &quot;GiantEbike.h&quot;
Bicycle* GiantFactory::createBicyle()
{
    return new GiantBicyle();
}

Ebike * GiantFactory::createEbike()
{
    return new GiantEbike();
}




//  ----------------------------------------------------------------------------
/**
 * @file  XdsFactory.h 
 */
#include &quot;Factory.h&quot;
class XdsFactory : public Factory {
public:
    Bicycle * createBicyle() override;
    Ebike * createEbike() override;
};

//  ----------------------------------------------------------------------------
/**
 * @file  XdsFactory.cpp
 */
#include &quot;XdsBicycle.h&quot;
#include &quot;XdsEbike.h&quot;
Bicycle* XdsFactory::createBicyle()
{
    return new XdsBicyle();
}

Ebike * XdsFactory::createEbike()
{
    return new XdsEbike();
}
</code></pre>
<p>调用代码如下：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  main.cpp 
 */
#include &quot;MeridaFactory.h&quot;
#include &quot;GiantFactory.h&quot;
#include &quot;XdsFactory.h&quot;
int main()
{
    MeridaFactory meridaBuilder;
    Bicycle* pMeridaBicyle = meridaBuilder.createBicyle();
    Ebike* pMeridaEbike = meridaBuilder.createEbike();
    pMeridaBicyle-&gt;show();
    pMeridaEbike-&gt;show();
    delete pMeridaBicyle;
    delete pMeridaEbike;
    
    GiantFactory giantBuilder;
    Bicycle* pGiantBicyle = giantBuilder.createBicyle();
    Ebike* pGiantEbike = giantBuilder.createEbike();
    pGiantBicyle-&gt;show();
    pGiantEbike-&gt;show();
    delete pGiantBicyle;
    delete pGiantEbike;
    
    XdsFactory xdsBuilder;
    Bicycle* pXdsBicyle = xdsBuilder.createBicyle();
    Ebike* pXdsEbike = xdsBuilder.createEbike();
    pXdsBicyle-&gt;show();
    pXdsEbike-&gt;show();
    delete pXdsBicyle;
    delete pXdsEbike;
    
    return 0;
}
</code></pre>
<h2 id="关于资源回收">关于资源回收</h2>
<p>工厂模式重点关注了类对象创建的问题，而关于类对象销毁的收尾工作并没有提及；</p>
<p>首先，考虑将对象的销毁放在对象的提供方--工厂类中。这样做有一个缺点，即当工厂类的变量生命周期结束时，产品类对象也随即销毁，而很多时候需要产品类对象的生命周期比工厂的生命周期长很多；同时由于“工厂模式”这样的字面含义就是“生产产品”，并没有销毁的意思；所以无论从需求上还是语义上，这样做都是不合理的；</p>
<p>接下来考虑将对象的销毁放在对象的使用方中。除非在工厂类接口的文档中进行详细说明，否则使用方只知道得到了一个对象的指针，并不了解其生命周期由谁管理，使用后贸然销毁可能会带来重复销毁的隐患；同时，另外一个问题是在具有一定规模的程序中常常会忘记销毁资源从而引起内存泄漏；所以这样做也是不合适的；</p>
<p>比较好的解决方法是使用智能指针 std::unique_ptr&lt;T&gt;，将资源的生命周期交由智能指针管理，这样也符合C++RAII的思想理念，同时也不用考虑资源由谁回收的问题了。具体做法是在工厂类中的对象创建函数返回一个智能指针，而不是一个裸指针，示例代码如下：</p>
<pre><code class="language-c++">//  ----------------------------------------------------------------------------
/**
 * @file  Factory.h 
 */
#include &lt;memory&gt;
class Factory {
public:
    virtual std::unique_ptr&lt;Bicycle&gt; createBicyle() = 0;
    virtual ~Factory() {}
};


//  ----------------------------------------------------------------------------
/**
 * @file  MeridaFactory.h 
 */
#include &quot;Factory.h&quot;
class MeridaFactory : public Factory {
public:
    std::unique_ptr&lt;Bicycle&gt; createBicyle() override;
};

//  ----------------------------------------------------------------------------
/**
 * @file  MeridaFactory.cpp
 */
#include &quot;MeridaBicycle.h&quot;
std::unique_ptr&lt;Bicycle&gt; MeridaFactory::createBicyle()
{
    return std::make_unique&lt;Bicycle&gt;();
}
</code></pre>
<h2 id="总结">总结</h2>
<p>工厂模式是不同模块之间传递资源的重要方式，其优点是资源的使用者无需了解资源提供者的实现细节，无源码依赖，只需遵循共同的抽象接口即可，这样两个模块就完成了解耦，相互独立，可以沿着各自方向变化；</p>
<p>简单工厂仅实现了最基本的源码隔离，遵循了依赖倒置原则；</p>
<p>工厂方法在简单工厂的基础上，还实现了当增加产品时仅扩展代码而不破坏代码的功能，遵循了开闭原则，</p>
<p>而抽象工厂仅在工厂方法的基础上拓展了创建产品的种类，其核心仍与工厂方法相同，无质的变化；</p>
<p>因此工厂方法是这三个工厂模式中最为重要的一个，其包含了两大核心观点：依赖倒置原则与开闭原则；其可作为工厂模式的典型代表在开发中多加理解与恰当应用；</p>
<h2 id="参考">参考</h2>
<ul>
<li>《设计模式--可复用面向对象软件的基础》，GoF，机械工业出版社，2000年09月；</li>
<li>《C++设计模式》课程，李建忠主讲；</li>
<li>《一文让你搞懂设计模式》博客，作者网名&lt;程序喵大人&gt;；</li>
<li><a href="https://www.cnblogs.com/xiaolincoding/p/11524376.html">《C++ 深入浅出工厂模式(初识篇)》博客， &lt;小林coding&gt;</a>；</li>
<li><a href="https://www.cnblogs.com/xiaolincoding/p/11524401.html">《C++ 深入浅出工厂模式(进阶篇)》博客， &lt;小林coding&gt;</a>；</li>
<li><a href="https://blog.csdn.net/silangquan/article/details/20492293">《三种工厂模式的C++实现》博客， &lt;拳四郎&gt;</a>；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++17结构化绑定]]></title>
        <id>https://wangtongxuewang.github.io/post/c17-jie-gou-hua-bang-ding/</id>
        <link href="https://wangtongxuewang.github.io/post/c17-jie-gou-hua-bang-ding/">
        </link>
        <updated>2021-11-22T10:58:27.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c17结构化绑定">C++17结构化绑定</h1>
<p>在开发中常常需要函数返回多个值，这在Python中十分容易，通过元组即可实现，示例代码如下：</p>
<pre><code class="language-python">def foo(x):
    y0 = x
    y1 = x**2
    y2 = x**3
    return (y0, y1, y2)
#end

x = 1.0
(y0, y1, y2) = foo(x)
</code></pre>
<p>然而在C++却是比较繁琐，在C++17之前，可以定义一个结构体来实现：</p>
<pre><code class="language-c++">struct ResFoo {
    double y0;
    double y1;
    double y2;
}

ResFoo foo(const double x)
{   
    ResFoo res;
    res.y0 = x;
    res.y1 = x * x;
    res.y2 = x * x * x;
    return res;
}

int main()
{
    double x = 1.0;
    ResFoo res = foo(x);
    double y0 = res.y0;
    double y1 = res.y1;
    double y2 = res.y2;
    
    // ...
    return 0; 
}
</code></pre>
<p>但是在C++17中，就可以使用结构化绑定并结合std::tuple，如同Python一样简洁地表达此意图：</p>
<pre><code class="language-c++">std::tuple&lt;double, double, double&gt; foo(const double x)
{
    return std::make_tuple&lt;double, double, double&gt;(x, x * x, x * x * x);
}

int main()
{
    double x = 1.0;
    auto [y0, y1, y2] = foo(x);
    
    // ...
    return 0;
}
</code></pre>
<p>与时俱进的C++标准让开发人员可以像使用动态语言一样编写C++代码，在开发中适当使用这样的“语法糖”会让我们的代码更加简洁优雅。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[智能指针与QVector组合使用问题]]></title>
        <id>https://wangtongxuewang.github.io/post/zhi-neng-zhi-zhen-yu-qvector-zu-he-shi-yong-wen-ti/</id>
        <link href="https://wangtongxuewang.github.io/post/zhi-neng-zhi-zhen-yu-qvector-zu-he-shi-yong-wen-ti/">
        </link>
        <updated>2021-08-14T03:58:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="智能指针与qvector组合使用问题">智能指针与QVector组合使用问题</h1>
<h2 id="引言">引言</h2>
<p>在C++开发中，由于Qt库接口完善易用，很多桌面端程序会使用Qt各种容器库[QTL]来代替STL，关于使用QTL还是STL，萝卜白菜，各有所爱，没有绝对优劣之分；</p>
<p>但是可能由于Qt库成型较早缘故，其未能考虑到现代C++的演化，当Qt库与现代C++标准库组合使用时，有时会产生一些意想不到的问题；</p>
<h2 id="问题由来">问题由来</h2>
<p>开发中，常常需要将对象指针序列放存放在 vector 中，比如Qt库中的QVector，且为了自动内存管理，会使用智能指针 unique_ptr 来自动管理内存 [使用 unique_ptr 而不是 shared_ptr 的原因是为了更好的区分所有权]；</p>
<p>为了阐明问题实质，将实际开发中的复杂问题简化为下述简单示例，但是麻雀虽小，五脏俱全，问题关键在下述代码已经体现：</p>
<pre><code class="language-c++">#include &lt;vector&gt;
#include &lt;unique_ptr&gt;
#include &lt;QVector&gt;

using std::vector;
using std::unique_ptr;

class CTest {
    // ...
};

int main()
{
    unique_ptr&lt;CTest&gt; ptr = std::make_unique&lt;CTest&gt;();
    
    QVector&lt;unique_ptr&lt;CTest&gt;&gt; ptrVec;  // 不能通过编译
    // vector&lt;unique_ptr&lt;CTest&gt;&gt; ptrVec;  // 可以通过编译
    
    ptrVec.push_back(std:move(ptr));
    
}
</code></pre>
<p>上述代码中，使用 QVector 时并不能通过编译，若将 QVector 替换成 std::vector，便能通过编译，正常运行；</p>
<h2 id="原因分析">原因分析</h2>
<p>当使用 QVector 时，编译器在 QVector 的 reallocData 函数中报错，详见下述代码与注释 [ 代码片段来自 Qt5.12.10 中的 qvector.h ] ：</p>
<pre><code class="language-C++">template &lt;typename T&gt;
void QVector&lt;T&gt;::reallocData(const int asize, const int aalloc, QArrayData::AllocationOptions options)
{
    // ...
    
    // QVector 隐式共享机制导致 unique_ptr 不能使用;
    // 下述代码中 isShared 值为 true , 可以通过对本部分代码的调试来验证这一点;
    if (isShared || !std::is_nothrow_move_constructible&lt;T&gt;::value) {
        // we can not move the data, we need to copy construct it
        while (srcBegin != srcEnd)
            new (dst++) T(*srcBegin++);    // 主要是本行代码需要使用 复制构造 产生问题
    } else {
        while (srcBegin != srcEnd)
            new (dst++) T(std::move(*srcBegin++));
    }
    
    // ...
}
</code></pre>
<p>通过上述代码的行为可知，由于 QVector 使用隐式共享[或称写时复制(COW : copy-on-write)]机制，reallocData 函数中的 isShared 值为 true，所以需要进行复制构造操作，而 std::unique_ptr 复制构造函数无法调用，所以编译器报错，不能通过编译；</p>
<p>std::unique_ptr 相关部分代码如下 [ 代码片段来自 mingw7.3.0 中的 unique_ptr.h ] ：</p>
<pre><code class="language-C++">template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt;
class unique_ptr {
    // ...

    // Disable copy from lvalue.
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
    
    // ...
};
</code></pre>
<p>上述问题也是所有问题中我们最希望出现的一类，因为能在编译期发现问题，这比在运行时出现意想不到的错误要好很多，这也是编译型语言的优势所在；</p>
<h2 id="最佳实践">最佳实践</h2>
<p>上述问题的根源是 QVector<T> 内部设计所致：QVector<T> 使用隐式共享机制，其在reallocData 等函数实现中需要使用类的复制构造， 因此 QVector<T> 不适合存放复制构造函数无法调用的类，具体包含下述两种情况：</p>
<ul>
<li>复制构造函数 =delete；</li>
<li>复制构造函数为 private；</li>
</ul>
<p>示例代码如下：</p>
<pre><code class="language-C++">// 不能使用 QVector&lt;T&gt; 的情况1 : 赋值构造函数 被删除
class Demo1 {
public:
    Demo1() = default;
    Demo1(const Demo1&amp; rhs) = delete;
    Demo1&amp; operator=(const Demo1&amp; rhs) = delete;
    Demo1(Demo1&amp;&amp; rhs) = default;
    Demo1&amp; operator=(Demo1&amp;&amp; rhs) = default;
    ~Demo1() = default;
    
    // ...   
private:
    Obj m_obj;
};


// 不能使用 QVector&lt;T&gt; 的情况2 : 赋值构造函数 私有化
class Demo2 {
public:
    Demo2() = default;
    Demo2(Demo2&amp;&amp; rhs) = default;
    Demo2&amp; operator=(Demo2&amp;&amp; rhs) = default;
    ~Demo2() = default;

private:
    Demo2(const Demo2&amp; rhs);
    Demo2&amp; operator=(const Demo2&amp; rhs);
    
    // ...   
private:
    Obj m_obj;
};
</code></pre>
<p>Qt 中 QVector<T> 以及 QString 等库的设计中采用了隐式共享的技术以提高性能，但是有些情况下会导致类似上述问题，而 GCC 等主流编译器中标准库对 vector<T> 与 string 等的实现并不采用此技术，故不会产生以上问题，Qt 库不知后期会不会改进设计，以更好的兼容标准库；</p>
<h2 id="后记">后记</h2>
<p>后来搜索了一下，发现在 StackOverflow 中也有类似的问题：</p>
<p><a href="https://stackoverflow.com/questions/53006163/use-stdfind-on-qvectorstdunique-ptrtype"> Use std::find on QVector&lt;std::unique_ptr<Type>&gt; </a></p>
<p>其中回答也给出了简要解释，若要更为详细的介绍，可阅读本文；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[观察者模式]]></title>
        <id>https://wangtongxuewang.github.io/post/guan-cha-zhe-mo-shi/</id>
        <link href="https://wangtongxuewang.github.io/post/guan-cha-zhe-mo-shi/">
        </link>
        <updated>2021-08-07T02:18:11.000Z</updated>
        <content type="html"><![CDATA[<h1 id="观察者模式">观察者模式</h1>
<p>观察者模式是开发中常用的设计模式之一，C++Qt库中的信号槽机制就是观察者模式的典型代表，关于信号槽机制的原理与简化实现，读者可自行查阅相关资料；</p>
<p>本文仅对观察者模式做一个简要介绍：</p>
<h2 id="目的">目的</h2>
<p>实现类似 “发布-订阅” 这样的需求，且信息发布者与订阅者之间应当是松耦合，以使得发布者与订阅者独立变化，信息发布者只要广播信息而无需了解具体的信息订阅者，同时信息订阅者可以自行决定如何响应；</p>
<h2 id="概念">概念</h2>
<p>定义对象间一种一对多的依赖关系，当一个对象状态发生改变时，所有依赖于它的对象都得到通知并自动更新；</p>
<h2 id="示例">示例</h2>
<p>观察者模式中信息发布者与订阅者需要松耦合设计，实现松耦合的重要方式就是多态技术，即利用类继承与虚函数重写来对不同的类约定相同的函数接口，C++示例代码如下：</p>
<pre><code class="language-C++">#ifndef OBSERVER_H
#define OBSERVER_H

#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

class AbstractObserver {   
public:    
    AbstractObserver();
    virtual ~AbstractObserver();
    
    virtual void update() {
        std::cout &lt;&lt; &quot;AbstractObserver update.&quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

class Observer1 : public AbstractObserver {    
public:  
    virtual void update() override {        
        std::cout &lt;&lt; &quot;Observer1 update.&quot; &lt;&lt; std::endl; 
        // ...
    }
};

class Observer2 : public AbstractObserver { 
public:  
    virtual void update() override {        
        std::cout &lt;&lt; &quot;Observer2 update.&quot; &lt;&lt; std::endl;    
    }
};

class Observer3 : public AbstractObserver { 
public:  
    virtual void update() override {        
        std::cout &lt;&lt; &quot;Observer3 update.&quot; &lt;&lt; std::endl;    
    }
};

class Publisher {   
public:    
    void addSubscriber(AbstractObserver * observer) { 
        auto itor = std::find(m_observers.cbegin(), m_observers.cend(), observer);
        if (itor != m_observers.cend()) {
            std::cout &lt;&lt; &quot;Add failed : duplicated add.&quot; &lt;&lt; std::endl; 
            return;
        }
        m_observers.push_back(observer); 
    }
    
    void removeSubscriber(AbstractObserver * observer) { 
        m_observers.remove(observer); 
    }
    
    void publish() {        
        for (AbstractObserver* ele : m_observers) {            
            ele-&gt;update();        
        }    
    }
    
    // ...
private:    
    std::list&lt;AbstractObserver*&gt; m_observers;
};

#endif  // OBSERVER_H
</code></pre>
<p>主函数：</p>
<pre><code class="language-C++">#include &lt;memory&gt;
#include &quot;observer.h&quot;

using std::unique_ptr;

int main() 
{    
    unique_ptr&lt;AbstractObserver&gt; observer1 = std::make_unique&lt;Observer1&gt;();  
    unique_ptr&lt;AbstractObserver&gt; observer2 = std::make_unique&lt;Observer2&gt;(); 
    unique_ptr&lt;AbstractObserver&gt; observer3 = std::make_unique&lt;Observer3&gt;(); 
    
    Publisher publisher;    
    publisher.addSubscriber(observer1.get());    
    publisher.addSubscriber(observer2.get());    
    publisher.addSubscriber(observer3.get());
    publisher.publish();
    
    publisher.removeSubscriber(observer2.get());    
    publisher.publish();
    
    // ... 
    
    return 0;
}
</code></pre>
<h2 id="参考">参考</h2>
<p>本文参考 同 本博客前述&lt;面向对象设计&gt;一文中所参考项；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[策略模式]]></title>
        <id>https://wangtongxuewang.github.io/post/ce-lue-mo-shi/</id>
        <link href="https://wangtongxuewang.github.io/post/ce-lue-mo-shi/">
        </link>
        <updated>2021-08-02T11:10:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="策略模式">策略模式</h1>
<h2 id="目的">目的</h2>
<p>在开发过程中，常使用 if-else 这样的多个分支来应对程序中的多种情况，每一个分支就是一种情况；随着需求的不断增多，分支将会迅速膨胀，造成代码块的冗长，且很有可能这样的分支远不止一处，这会给代码的维护扩展带来极大困难，策略模式可以用来解决上述问题；</p>
<h2 id="概念">概念</h2>
<p>策略模式概念：定义一系列算法，将各算法进行封装，使得它们可以相互替换；</p>
<p>策略模式让算法独立于使用它的用户而变化，当有新的算法时，代码进行扩展即可，无需过多变动；</p>
<p>一般在项目中，若发现多个 if-else 且预计还会在此增加多个 if-else 分支，那很有可能需要使用策略模式；</p>
<p>策略模式将算法行为封装为对象，以便动态选择，而不是使用显式 if-else；</p>
<h2 id="示例">示例</h2>
<h3 id="重构代码对比策略模式">重构代码对比策略模式</h3>
<p>分别列举未使用策略模式的原始代码与使用策略模式的重构后代码进行对比，两者代码分述如下；</p>
<p>原始代码：</p>
<pre><code class="language-C++">enum class GridGenMethod {    
    TransfiniteInterp,    
    EllipticEqs,
    AdvancingFrontTech,
    DelaunayTri
};

// ...


// 用户代码
void genGrid(const GridGenMethod method) 
{   
    std::cout &lt;&lt; &quot;gen grid start.&quot; &lt;&lt; std::endl; 
    
    if (method == GridGenMethod::TransfiniteInterp) {        
        std::cout &lt;&lt; &quot;TransfiniteInterp Method : &quot; &lt;&lt; std::endl;  
        // ...
    } else if (method == GridGenMethod::EllipticEqs) {        
        std::cout &lt;&lt; &quot;EllipticEqs Method : &quot; &lt;&lt; std::endl;  
        // ...   
    } else if (method == GridGenMethod::AdvancingFrontTech) {
        std::cout &lt;&lt; &quot;AdvancingFrontTech Method : &quot; &lt;&lt; std::endl;  
        // ...
    } else if (method == GridGenMethod::DelaunayTri) {
        std::cout &lt;&lt; &quot;DelaunayTri Method : &quot; &lt;&lt; std::endl;  
        // ...
    }
    
    // ...
    
    std::cout &lt;&lt; &quot;gen grid finish.&quot; &lt;&lt; std::endl;
}

int main()
{
    GridGenMethod method = GridGenMethod::EllipticEqs;
    genGrid(method);
    
    // ...
    return 0;
}

</code></pre>
<p>使用策略模式重构后代码：</p>
<pre><code class="language-C++">// 库代码
class GridGenerator {   
public:
    GridGenerator() = default;
    GridGenerator(const GridGenerator&amp; rhs) = default;
    GridGenerator&amp; operator=(const GridGenerator&amp; rhs) = default;
    GridGenerator(GridGenerator&amp;&amp; rhs) = default;
    GridGenerator&amp; operator=(GridGenerator&amp;&amp; rhs) = default;
    virtual ~GridGenerator() {
        // ...
    }
    virtual void genGrid() { 
        std::cout &lt;&lt; &quot;virtual genGrid&quot; &lt;&lt; std::endl; 
    }
private:
    //...
};

class TransfiniteInterpGenerator : public GridGenerator {    
    virtual void genGrid() override { 
        std::cout &lt;&lt; &quot;TransfiniteInterp Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
};

class EllipticEqsGenerator : public GridGenerator {    
    virtual void genGrid() override { 
        std::cout &lt;&lt; &quot;EllipticEqs Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
};

class AdvancingFrontTechGenerator : public GridGenerator {    
    virtual void genGrid() override { 
        std::cout &lt;&lt; &quot;AdvancingFrontTech Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
};

class DelaunayTriGenerator : public GridGenerator {    
    virtual void genGrid() override { 
        std::cout &lt;&lt; &quot;DelaunayTri Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
};

// 若后续有新的方法，还可以在此添加新方法的代码
// ...

// 用户代码 : 相比于原始代码，精简了很多
int main() 
{    
    std::unique_ptr&lt;GridGenerator&gt; gridGen = std::make_unique&lt;EllipticEqsGenerator&gt;();
    gridGen-&gt;genGrid();
    // ...
    
    return 0;
}
</code></pre>
<p>每增加一种方法，就增加一个继承基类的子类，重写 genGrid() 函数进行代码扩展即可；</p>
<p>观察上述代码，模板方法的代码和策略模式看起来很类似，但两者有很大区别：</p>
<ul>
<li>
<p>模板方法侧重的是将整体框架流程提供给代码使用者，代码使用者重新实现某一些具体行为即可；</p>
</li>
<li>
<p>策略模式侧重的是将算法库代码分别封装，使得它们可以相互替换，代码使用者选择其一即可；</p>
</li>
</ul>
<p>当然，两种模式均使用了C++继承与重写机制来实现各自模式；</p>
<h3 id="使用函数对象">使用函数对象</h3>
<p>还可以使用C++中函数对象来实现策略模式，与C++继承及重写类似，但是更直观易懂，代码如下：</p>
<pre><code class="language-c++">// 库代码
class TransfiniteInterpGenerator {
public:
    void operator()() { 
        std::cout &lt;&lt; &quot;TransfiniteInterp Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

class EllipticEqsGenerator {
public:
    void operator()() { 
        std::cout &lt;&lt; &quot;EllipticEqs Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

class AdvancingFrontTechGenerator {
public:
    void operator()() { 
        std::cout &lt;&lt; &quot;AdvancingFrontTech Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

class DelaunayTriGenerator { 
public:
    void operator()() { 
        std::cout &lt;&lt; &quot;DelaunayTri Method : &quot; &lt;&lt; std::endl; 
        // ...
    }
    // ...
};

// 若后续有新的方法，还可以在此添加新方法的代码
// ...

class GridGenerator {
public:
    enum class GridGenMethod {    
        TransfiniteInterp,    
        EllipticEqs,
        AdvancingFrontTech,
        DelaunayTri
    };
    static std::function&lt;void(void)&gt; genGrid(const GridGenMethod method) {
        return s_methodFunc.at(method);
    }
private:
    static map&lt;GridGenMethod, std::function&lt;void(void)&gt;&gt; s_methodFunc = {
        {GridGenMethod::TransfiniteInterp   , TransfiniteInterpGenerator()},
        {GridGenMethod::EllipticEqs         , EllipticEqsGenerator()},
        {GridGenMethod::AdvancingFrontTech  , AdvancingFrontTechGenerator()},
        {GridGenMethod::DelaunayTriGenerator, DelaunayTriGenerator()}
    };  
};


// 用户代码
void main() 
{  
    GridGenerator::GridGenMethod method = GridGenerator::GridGenMethod::EllipticEqs;
    std::function&lt;void(void)&gt; gridGen = GridGenerator::genGrid(method);
    gridGen();
    // ...
    
    return 0;
} 
</code></pre>
<h2 id="参考">参考</h2>
<p>本文参考 同 本博客前述&lt;面向对象设计&gt;一文中所参考项；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[模板方法]]></title>
        <id>https://wangtongxuewang.github.io/post/mo-ban-fang-fa/</id>
        <link href="https://wangtongxuewang.github.io/post/mo-ban-fang-fa/">
        </link>
        <updated>2021-07-15T12:29:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="模板方法">模板方法</h1>
<p>以下介绍几种常用的设计模式，既作复习，也是在开发实践中对于设计模式的再理解；</p>
<p>顺序并不按照主要教材所列，且有些内容掺杂个人理解，并非完全正确，欢迎交流探讨；</p>
<p>首先从模板方法开始；</p>
<h2 id="目的">目的</h2>
<p>在开发中常会遇到这样的情况：自己写的库中，一个功能的流程是固定的，且大部分步骤具体实现也是固定的，但是其中某一些步骤的具体实现无法确定，是由使用该库的人进行开发，那么如何让别人使用该库时能够复用自己的代码呢？这就是模板方法的使用场景；</p>
<h2 id="概念">概念</h2>
<p>模板方法：定义一个操作中稳定不变的算法骨架，将一些步骤延迟到变化的子类中，其目的是使得子类可以复用一个算法框架；</p>
<h2 id="示例">示例</h2>
<p>在C++中，具体方法是，使用虚函数与继承实现模板方法，简单示例如下：</p>
<pre><code class="language-C++">class Solver {   
public:    
    Solver() = default;
    virtual ~Solver() = default;
    
    void solve() 
    {        
        preprocess();        
        compute();        
        postprocess();    
    }
protected:    
    virtual void compute() 
    { 
        // 常常变化
        // ...
    }
private:    
    void preprocess() 
    { 
        // 稳定的实现
        // ...
    }    
    void postprocess() 
    { 
        // 稳定的实现
        // ...
    }
    
    // ...
};


class SolverA : public Solver {
protected:     
    virtual void compute() override 
    { 
        // SolverA 的计算过程
    }
    
    // ...
};

class SolverB : public Solver {    
protected:    
    virtual void compute() override 
    { 
        // SolverB 的计算过程
    }
    
    // ...
};

class SolverC : public Solver {    
protected:    
    virtual void compute() override 
    { 
        // SolverC 的计算过程
    }
    
    // ...
};

#include &lt;vector&gt;
#include &lt;memory&gt;

using std::vector
using std::unique_ptr;

int main() 
{
    unique_ptr&lt;Solver&gt; solA = std::make_unique&lt;SolverA&gt;();
    unique_ptr&lt;Solver&gt; solB = std::make_unique&lt;SolverB&gt;();
    // ...
    
    vector&lt;unique_ptr&lt;Solver&gt;&gt; sol;
    sol.push_back(std::move(solA));
    sol.push_back(std::move(solB));
    // ...
    
    for (int i = 0; i &lt; sol.size(); ++i) {
        sol[i]-&gt;solve();
    }
    // ...
    
    return 0;
}
</code></pre>
<p>上述代码中，Solver包含：前处理，计算，后处理三个稳定的过程，其中前处理与后处理具体实现是固定的，但是“计算”因具体方法而异，所以使用模板方法，只需实现不同的计算方法即可， 而算法流程框架、前处理与后处理代码均得到复用；</p>
<h2 id="参考">参考</h2>
<p>本文参考 同 本博客前述&lt;面向对象设计&gt;一文中所参考项；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象设计]]></title>
        <id>https://wangtongxuewang.github.io/post/mian-xiang-dui-xiang-she-ji/</id>
        <link href="https://wangtongxuewang.github.io/post/mian-xiang-dui-xiang-she-ji/">
        </link>
        <updated>2021-07-03T02:22:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="面向对象设计">面向对象设计</h1>
<h2 id="目标与方法">目标与方法</h2>
<p>随着程序代码不断扩张，软件中各部分交互关系日益庞杂，其维护扩展变得异常困难，为应对此危机，面向对象设计方法得到不断发展，其要实现的目标与所用方法如下：</p>
<ul>
<li>实现目标：模块相互独立，即插即用；</li>
<li>使用方法：约定抽象接口，减少依赖；</li>
</ul>
<h2 id="特点">特点</h2>
<p>面向对象的设计有三大特点，区别于其他编程范式，分别为：</p>
<ul>
<li>封装：隐藏内部实现，达到使用接口编程而不用了解内部实现的目的；</li>
<li>继承：继承父类的属性与数据，达到代码复用的目的；</li>
<li>多态：对于同一种接口，不同的类型的对象展现不同的行为，达到接口统一的目的；</li>
</ul>
<h2 id="基本原则">基本原则</h2>
<p>为实现面向对象设计的目标，开发领域在长期理论与实践中总结出几个基本原则，不同的教材的阐述略有不同，但是表达的基本思想是一致的，最为经典的说法是将面向对象设计的这几个原则称为“SOLID”原则，名称取自这五个原则的英文缩写首字母，同时寓意在这几个原则指导下所开发软件系统的稳固性；</p>
<h3 id="单一职责原则-srp-single-responsibility-principle">单一职责原则 (SRP - Single Responsibility Principle)</h3>
<p>一个类只做一件事，一个类应该仅有一个引起它变化的原因，且其变化隐含着类的责任；</p>
<p>比如，在实际开发中，对大的类进行拆解，减少类中蕴含不同概念的成员变量与成员函数；</p>
<h3 id="开放封闭原则-ocp-open-closed-principle">开放封闭原则 (OCP - Open Closed Principle)</h3>
<p>对扩展开放，对修改关闭；即当程序需要扩展的时候，尽量不要去修改原来的代码，而应复用扩展代码，使其易于维护和升级，同时还能减少编译时间；</p>
<p>因此在开发中，要利用好继承与组合等方法，约定抽象接口，让系统中的组件相互解耦，互不影响；</p>
<h3 id="里氏替换原则-lsp-liskov-substitution-principle">里氏替换原则 (LSP - Liskov Substitution Principle)</h3>
<p>子类必须能够替换父类，即子类对象若看作是抽象父类使用时，其接口行为须与抽象语义所期望的一致，这也是开闭原则具体实现手段之一；</p>
<p>所以在实际开发中，使用继承实现约定的抽象接口，可以对同一抽象语义实现不同的具体方法；</p>
<p>这条原则也提示我们：</p>
<ul>
<li>在开发中不要仅仅为了使用一个类的属性或方法就使用继承，此时应该使用组合代替继承；</li>
<li>真正使用继承的地方应该是：一个类的概念是另一个类的概念的更上一层抽象；</li>
</ul>
<h3 id="接口隔离原则-isp-interface-segregation-principle">接口隔离原则 (ISP - Interface Segregation Principle)</h3>
<p>接口应小而完备，程序不要依赖不需要的部分；若不需要的接口太多，则会给用户程序更多困惑，且相应具体实现也会增多；当不需要的接口被修改，那么其依赖者也要被重新编译部署；</p>
<p>所以在开发中，public的抽象接口应该尽量少而精；</p>
<h3 id="依赖倒置原则-dip-dependency-inversion-principle">依赖倒置原则 (DIP - Dependency Inversion Principle)</h3>
<p>针对接口编程，程序应依赖于抽象接口而不依赖于具体实现；</p>
<p>抽象不应依赖于实现细节，而应反过来，让实现细节依赖于抽象，因为抽象接口一般是经过长期设计共同约定，是稳定的，而实现细节一般是多样且多变的；</p>
<p>所以在开发中，需精心设计抽象接口，力求抽象接口稳定，同时让具体实现依赖于(使用继承)抽象接口，当具体实现变动时，抽象接口无需变化；</p>
<h2 id="设计模式">设计模式</h2>
<p>在五大设计原则指导下，经过长期工程实践，开发领域总结出了很多实用的设计“套路”，其中最为经典与广泛使用的就是各教科书中介绍的23种设计模式；</p>
<p>随着软件开发领域的不断发展，各种设计模式还在不停的变化，但是这些设计模式所体现的设计原则是一直稳固不变的；</p>
<p>关于设计模式，篇幅所限，在本文中便不再展开；</p>
<h2 id="总结">总结</h2>
<p>我们在面向对象编程实践中，需要不断理解巩固并灵活应用面向对象的基本原则与各种设计模式，不断提升程序的可维护性与可扩展性，在此与大家共勉；</p>
<h2 id="参考">参考</h2>
<ul>
<li>GoF，设计模式--可复用面向对象软件的基础，机械工业出版社，2000年09月；</li>
<li>李建忠，C++设计模式课程；</li>
<li>程序喵大人 ，一文让你搞懂设计模式；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++的值类别]]></title>
        <id>https://wangtongxuewang.github.io/post/cde-zhi-lei-bie/</id>
        <link href="https://wangtongxuewang.github.io/post/cde-zhi-lei-bie/">
        </link>
        <updated>2021-06-21T10:40:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c的值类别">C++的值类别</h1>
<h2 id="值类别">值类别</h2>
<p>C++表达式有两种属性：类型(type)和值类别(value category)。其中类型主要区别值的大小与解读方式，此属性是大家熟知的，故不赘述，以下内容主要阐述值类别。</p>
<p>每个表达式只属于三种值类别中的一种，纯右值(prvalue)、亡值(xvalue)、左值(lvalue)；纯右值和亡值统称为右值(rvalue)，亡值和左值统称为泛左值(glvalue)；以上对于值类别的表述可能难以理解，以下进行详细解释；</p>
<p>在C++11中，值类别主要用以表达区别表达式<strong>是否拥有身份</strong>以及<strong>是否可被移动</strong>：</p>
<ul>
<li>拥有身份(泛左值)：可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的地址；</li>
<li>可被移动(右值)：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式；</li>
</ul>
<p>即拥有身份的表达式被称作泛左值表达式，可被移动的表达式被称作右值表达式，同时又有：</p>
<ul>
<li>拥有身份 且 不可被移动 的表达式被称作*左值 (lvalue)*表达式 [只属于泛左值表达式]；</li>
<li>拥有身份 且 可被移动 的表达式被称作*亡值 (xvalue)*表达式 [既属于泛左值表达式，又属于右值表达式]；</li>
<li>不拥有身份 且 可被移动 的表达式被称作*纯右值 (prvalue)*表达式 [只属于右值表达式]；</li>
<li>不拥有身份 且 不可被移动 的表达式无法使用；</li>
</ul>
<p>使用树状图直观展示如下：<br>
[需复制下述文字并使用typora打开]</p>
<pre><code class="language-mermaid">graph TB
A(表达式)
B(泛左值)
C(右值)
D(左值)
E(亡值)
F(纯右值)

A--&gt;B
A--&gt;C
B--&gt;D
B--&gt;E
C--&gt;E
C--&gt;F
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://wangtongxuewang.github.io/post-images/1624275021149.jpg" alt="" loading="lazy"></figure>
<h2 id="移动语义">移动语义</h2>
<p>在C++11中引入新的值类别的概念，其中重要目的就是应用移动语义，以此减少很多不必要的拷贝，从而大幅度提升性能；</p>
<p>实现“移动”主要是依靠std::move(), 其主要功能其实并不是真正的移动，而是将表达式值类别强制转换为右值型别，其具体实现在C++STL中如下所示 [ 代码片段来自 MinGW7.3.0 中的 move.h ]</p>
<pre><code class="language-c++">/**
  *  @brief  Convert a value to an rvalue.
  *  @param  __t  A thing of arbitrary type.
  *  @return The parameter cast to an rvalue-reference to allow moving it.
  */
template&lt;typename _Tp&gt;
constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;
move(_Tp&amp;&amp; __t) noexcept
{ 
    return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); 
}
</code></pre>
<h2 id="应用举例">应用举例</h2>
<p>下述例子并不能体现 std::move() 的优点，只是作为一个简单例子进行说明：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;memory&gt;

using std::cout;
using std::endl;
using std::unique_ptr;

class Demo {
public:
    Demo() = default;
    Demo(const Demo&amp; rhs) = default;
    Demo(Demo&amp;&amp; rhs) = default;
    Demo&amp; operator=(const Demo&amp; rhs) = default;
    Demo&amp; operator=(Demo&amp;&amp; rhs) = default;
    ~Demo() = default;
private:
    int m_a = 1;
    // ...
};


int main()
{
    unique_ptr&lt;Demo&gt; ptrDemo = std::make_unique&lt;Demo&gt;();

    cout &lt;&lt; &quot;ptrDemo : &quot; &lt;&lt; ptrDemo.get() &lt;&lt; endl;

    // unique_ptr不支持拷贝构造与拷贝赋值操作
    unique_ptr&lt;Demo&gt; ptrDemo2 = std::move(ptrDemo);
    assert(ptrDemo == nullptr);

    cout &lt;&lt; &quot;ptrDemo : &quot; &lt;&lt; ptrDemo.get() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptrDemo2 : &quot; &lt;&lt; ptrDemo2.get() &lt;&lt; endl;

    // ...

    return 0;
}

</code></pre>
<p>终端输出：</p>
<pre><code class="language-c++">// console output : 
ptrDemo : 0x1304b68
ptrDemo : 0
ptrDemo2 : 0x1304b68
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://www.cnblogs.com/zhao-zongsheng/p/value_categories_and_move_semantics.html">C++11的value category(值类别)以及move semantics(移动语义)</a></p>
<p><a href="https://zh.cppreference.com/w/cpp/language/value_category">cppreference - value_category</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[运行时类型识别]]></title>
        <id>https://wangtongxuewang.github.io/post/yun-xing-shi-lei-xing-shi-bie/</id>
        <link href="https://wangtongxuewang.github.io/post/yun-xing-shi-lei-xing-shi-bie/">
        </link>
        <updated>2021-06-13T09:26:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="运行时类型识别">运行时类型识别</h1>
<p>运行时类型识别(RTTI)主要作用是获得指针及引用变量的实际类型, 其主要操作有两种, 分别是 获取实际类型 与 安全类型转换；</p>
<h2 id="获取实际类型">获取实际类型</h2>
<p>获取实际类型主要依靠:  typeid 关键字 与 type_info 类, 示例代码如下:</p>
<p>类代码:</p>
<pre><code class="language-c++">// demo.h
class Demo {
public:
    Demo() = default;
    virtual ~Demo() = default;

    virtual void disp()  {cout &lt;&lt; &quot;Demo&quot; &lt;&lt; endl;}

    inline double dispA() {return m_a;}
private:
    double m_a = 10.0;
};


class DemoDerived : public Demo {
public:
    DemoDerived() = default;
    ~DemoDerived() = default;

    virtual void disp() override {cout &lt;&lt; &quot;DemoDeriv&quot; &lt;&lt; endl;}

    inline double dispB() {return m_b;}
private:
    double m_b = 8.0;
};
</code></pre>
<p>主函数:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

#include &quot;demo.h&quot;

using std::cout;
using std::endl;
using std::type_info;


int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new DemoDerived();

    const type_info&amp; type1 = typeid (*demo1);
    const type_info&amp; type2 = typeid (*demo2);

    cout &lt;&lt; type1.name() &lt;&lt; endl;
    cout &lt;&lt; type2.name() &lt;&lt; endl;

    delete demo1;
    delete demo2;

    return 0;
}
</code></pre>
<p>终端输出:</p>
<pre><code class="language-c++">// console output : 
4Demo
11DemoDerived
</code></pre>
<p>不同编译器可能输出略微不同, 但是仍可看到两个指针所指向的实际类型分别为 Demo 与 DemoDerived, 其中数字表示类型名称的字符长度；</p>
<h2 id="安全类型转换">安全类型转换</h2>
<p>在基类与继承类之间进行安全类型转换主要依靠 dynamic_cast&lt;&gt;() 操作, 示例代码如下；</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

#include &quot;demo.h&quot;

using std::cout;
using std::endl;
using std::type_info;


int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new DemoDerived();

    DemoDerived* demoCast1 = dynamic_cast&lt;DemoDerived*&gt;(demo1);
    DemoDerived* demoCast2 = dynamic_cast&lt;DemoDerived*&gt;(demo2);

    cout &lt;&lt; &quot;demoCast1 addr = &quot; &lt;&lt; demoCast1 &lt;&lt; endl;
    cout &lt;&lt; &quot;demoCast2 addr = &quot; &lt;&lt; demoCast2 &lt;&lt; endl;

    delete demo1;
    delete demo2;

    return 0;
}
</code></pre>
<p>上述代码终端输出:</p>
<pre><code class="language-c++">// console output : 
demoCast1 addr = 0
demoCast2 addr = 0x55555556aed0
</code></pre>
<p>其中, demo2 的实际类型是 DemoDerived, 所以动态类型转换成功, demoCast2是有效地址；demo1 的实际类型 Demo, 所以动态类型转换失败, demoCast1 地址为 0, 是无效地址, 表示了这种转换是不正确的, 这正是动态类型转换的安全性所在；</p>
<p>而静态类型转换 static_cast 不会检查类型转换之间的安全性, 反而会引起一些潜在危险,且难以排查, 示例代码如下:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

#include &quot;demo.h&quot;

using std::cout;
using std::endl;
using std::type_info;

int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new DemoDerived();

    DemoDerived* ptrDemoError = static_cast&lt;DemoDerived *&gt;(demo1);

    cout &lt;&lt; &quot;ptrDemoError addr = &quot; &lt;&lt; ptrDemoError &lt;&lt; endl;

    cout &lt;&lt; ptrDemoError-&gt;dispA() &lt;&lt; endl;
    cout &lt;&lt; ptrDemoError-&gt;dispB() &lt;&lt; endl;

    delete demo1;
    delete demo2;

    return 0;
}
</code></pre>
<p>上述代码终端输出为:</p>
<pre><code class="language-c++">// console output : 
ptrDemoError addr = 0x55555556aeb0
10
0
</code></pre>
<p>虽然上述代码中的类型转换是不正确的, 但是静态类型转换仍然能够获得demo1的地址, 而后其错误地使用了DemoDerived中的dispB(), 给出了错误的结果；这种错误排查难度远远大于程序意外终止等明显的问题；</p>
<p>所以, 在基类与继承类之间的转换中尽量只使用 dynamic_cast, 不要使用C风格的强制类型转换 与 static_cast 等不安全的类型转换, 除非自己明确知道这种类型的转换一定是正确的, 否则产生错误可能非常难以排查；</p>
<h2 id="总结">总结</h2>
<p>运行时类型识别RTTI虽然会降低程序性能, 但是适当使用提升了程序的安全性, 对编码起到事半功倍的效果；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 std::unique_ptr 的思考]]></title>
        <id>https://wangtongxuewang.github.io/post/guan-yu-stdunique_ptr-de-si-kao/</id>
        <link href="https://wangtongxuewang.github.io/post/guan-yu-stdunique_ptr-de-si-kao/">
        </link>
        <updated>2021-05-31T12:11:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于-stdunique_ptr-的思考">关于 std::unique_ptr 的思考</h1>
<p>std::unique_ptr 表示独占所有权的智能指针，正常情况下，此智能指针管理内存的获取与释放，而普通指针仅负责使用内存；</p>
<h2 id="禁止拷贝">禁止拷贝</h2>
<p>由于 std::unique_ptr 表示独占的含义，所以其是不支持拷贝的，在C++标准库中，unique_ptr 禁止拷贝的实现如下 [ 代码片段来自 MinGW5.3.0 中的 unique_ptr.h ]：</p>
<pre><code class="language-c++">template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt;
class unique_ptr {
public:
    // ...
    // Disable copy from lvalue.
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
    // ...
};
</code></pre>
<p>由代码可知，禁止拷贝的实现中采用了C++11的 delete 关键字；而在C++11之前，若要实现禁止拷贝的功能，传统方法是将拷贝构造与赋值运算符私有化，这样是非常不直观的，示例代码如下：</p>
<pre><code class="language-C++">// C++98/03风格的禁止拷贝实现方式
class Demo {
public:
    Demo();
    // ...
private:
    Demo(const Demo&amp; rhs);
    Demo&amp; operator=(const Demo&amp; rhs);
    // ...
}
</code></pre>
<h2 id="函数返回">函数返回</h2>
<p>在C++标准中，std::unique_ptr 是支持函数返回的，最为典型的就是 std::make_unique，其实现代码如下 [ 代码片段来自 MinGW5.3.0 中的 unique_ptr.h ]：</p>
<pre><code class="language-c++">/// std::make_unique for single objects
template&lt;typename _Tp, typename... _Args&gt;
inline typename _MakeUniq&lt;_Tp&gt;::__single_object
make_unique(_Args&amp;&amp;... __args)
{
    return unique_ptr&lt;_Tp&gt;(new _Tp(std::forward&lt;_Args&gt;(__args)...)); 
}
</code></pre>
<p>既然 std::unique_ptr 不支持拷贝，那么为什么其可以进行函数返回呢？这似乎与不支持拷贝是矛盾的；</p>
<p>我们知道，在函数返回中，返回值优化RVO(其在C++17中进入标准)可以让对象直接在函数调用处生成， 而不产生多余的临时对象，从而绕过拷贝/移动构造操作；</p>
<p>因此，std::unique_ptr 的能够函数返回的重要机制是返回值优化RVO绕过了拷贝/移动构造，使其能够函数返回；</p>
<h2 id="开发启示">开发启示</h2>
<p>如上所述，C++标准库在实现中大量应用了C++11/14/17等现代特性，如  =delete，RVO，等；</p>
<p>所以，在开发实践中，我们亦应编写现代C++风格的代码，与时俱进，才能让程序更优雅，更具维护性；</p>
]]></content>
    </entry>
</feed>