<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangtongxuewang.github.io</id>
    <title>王同学的博客</title>
    <updated>2021-04-25T04:14:47.951Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangtongxuewang.github.io"/>
    <link rel="self" href="https://wangtongxuewang.github.io/atom.xml"/>
    <subtitle>&lt;font size=&quot;10&quot;&gt;sharing&lt;/font&gt;</subtitle>
    <logo>https://wangtongxuewang.github.io/images/avatar.png</logo>
    <icon>https://wangtongxuewang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 王同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[C++函数传参方式]]></title>
        <id>https://wangtongxuewang.github.io/post/chan-shu-chuan-can-fang-shi/</id>
        <link href="https://wangtongxuewang.github.io/post/chan-shu-chuan-can-fang-shi/">
        </link>
        <updated>2021-04-25T04:13:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c函数传参方式">C++函数传参方式</h1>
<h2 id="引言">引言</h2>
<p>C++函数传参方式有很多种选择，可以传值、传指针、传引用、返回值等，故需要一种内部规范让函数参数传递简明易懂，同时兼顾性能；</p>
<h2 id="代码示例">代码示例</h2>
<p>以下代码使用了结构化绑定，需要编译器支持C++17；</p>
<pre><code class="language-c++">#include &lt;tuple&gt;

class CDemo1 {
    // ...
};

class CDemo2 {
    // ..
};

// 函数传参方式示例
std::tuple&lt;double, std::string&gt; testFunc(const int n, 
                                         const std::vector&lt;double&gt;&amp; x,
                                         CDemo1&amp; out1,
                                         CDemo2* out2 = nullptr)
{
    // do something
}

int main()
{
    const int n = 10;
    const std::vector&lt;double&gt; x = {1.1, 2.2, 3.3};
    CDemo1 d1;
    CDemo2 d2;
    auto [y, errInfo] = testFunc(n, x, d1, &amp;d2);
    
    // ...
    
    return 0;
}
</code></pre>
<h2 id="结论">结论</h2>
<p>通过上述代码示例，可总结函数传参中传值、传引用、传指针、函数返回值的的 <strong>最佳实践</strong>：</p>
<h3 id="函数入参">函数入参</h3>
<p>POD类型使用常值（如  const double x）；</p>
<p>类类型使用常引用（如  const T&amp; x）；</p>
<h3 id="函数出参">函数出参</h3>
<p>若有可能，优先使用函数返回值，尽量不要使用函数出参，以增强可读性；</p>
<p>若需要使用出参，优先使用 T&amp; ；</p>
<p>在出参中，若可能为空（如 有默认参数 = nullptr）或者其指向可能变化，才使用 T* ；</p>
<h3 id="函数返回值">函数返回值</h3>
<p>若是新产生的变量，则返回 单个/多个 值（类类型同样可以返回值，只要保证返回值优化发生，则性能与出参是一样的）；</p>
<p>若是修改函数体之外的变量，可返回比本函数生命周期更长变量的引用/指针；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++函数对象]]></title>
        <id>https://wangtongxuewang.github.io/post/chan-shu-dui-xiang/</id>
        <link href="https://wangtongxuewang.github.io/post/chan-shu-dui-xiang/">
        </link>
        <updated>2021-04-16T06:24:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c函数对象">C++函数对象</h1>
<h2 id="引言">引言</h2>
<p>在实际开发中我们常常希望函数定义与使用可以像变量一样方便，如：可以在一个函数作用域内临时定义，能够方便的当做函数参数进行传递等，而函数对象正是实现这类功能的理想方法；</p>
<p>概念：重载了 operator() 的类对象称为函数对象。当该对象调用 operator() 时，方式、效果同普通函数调用，故名函数对象，示例如下：</p>
<pre><code class="language-c++">class Demo {
public:
    // ...
    void operator() (void) {
        std::cout &lt;&lt; &quot;call operator() ()&quot; &lt;&lt; std::endl;
    }
    // ...
};
</code></pre>
<h2 id="lambda与stdfunction">lambda与std::function</h2>
<p>很多时候我们并不需要自己特地定义一个类并重载 operator() 这样复杂的操作，C++已经为我们提供了实现此功能的基础设施：lambda与std::function，以方便我们使用，示例代码如下：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{    
    std::function&lt;int(const int, const int)&gt; sum = [](const int a, const int b) -&gt; int {
        return a + b; 
    };
    
    auto dot = [](const int a, const int b) -&gt; int { return a*b; };
        
    int sumRes = sum(1, 2);
    int dotRes = dot(1, 2);
    
    std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sumRes &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;dot = &quot; &lt;&lt; dotRes &lt;&lt; std::endl;  
    
    std::vector&lt;int&gt; vec = {3, 1, 4};
    std::for_each(vec.cbegin(), vec.cend(), [](const int n) -&gt; void { 
        std::cout &lt;&lt; &quot;vec_i&quot; &lt;&lt; n &lt;&lt; std::endl; 
    });
}
</code></pre>
<h2 id="适用场景">适用场景</h2>
<p>lambda与std::function适用场景：</p>
<ul>
<li>在函数中定义一个临时函数，就像定义一个变量一样方便；</li>
<li>将函数对象作为参数传入另一个函数中，省去了传入函数指针的繁琐操作；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++STL迭代器]]></title>
        <id>https://wangtongxuewang.github.io/post/cstl-die-dai-qi/</id>
        <link href="https://wangtongxuewang.github.io/post/cstl-die-dai-qi/">
        </link>
        <updated>2021-04-15T01:30:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cstl迭代器">C++STL迭代器</h1>
<p>迭代器是开发中操作容器的常用工具，大部分迭代器操作在容器类成员函数中可直接使用；<br>
但是有一些操作直接使用容器成员函数中的方法可能并不方便，而C++STL中提供的迭代器辅助函数可简洁实现这些操作；<br>
故以下介绍C++STL中迭代器辅助函数，其与容器中成员函数迭代器相关方法结合使用，可有事半功倍的效果；<br>
其中有四个迭代器辅助函数最为常用，示例代码如下：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; vec = {3, 1, 4};
    std::vector&lt;int&gt;::iterator it = vec.begin();

    auto itBeg = std::begin(vec);    // 推荐使用容器类的成员函数
    auto itEnd = std::end(vec);    // 推荐使用容器类的成员函数

    // 以下是迭代器辅助函数最为常用的四种操作
    std::advance(it, 1);    // 跳转
    auto prev_it = std::prev(it);    // 上一个
    auto next_it = std::next(it);    // 下一个
    int dis = std::distance(prev_it, next_it);    // 两个游标之间距离
    
    std::cout &lt;&lt; &quot;*it = &quot; &lt;&lt; *it &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;dis = &quot; &lt;&lt; dis &lt;&lt; std::endl;

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++初始化最佳实践]]></title>
        <id>https://wangtongxuewang.github.io/post/cchu-shi-hua-zui-jia-shi-jian/</id>
        <link href="https://wangtongxuewang.github.io/post/cchu-shi-hua-zui-jia-shi-jian/">
        </link>
        <updated>2021-04-14T05:10:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c初始化最佳实践">C++初始化最佳实践</h1>
<h2 id="引言">引言</h2>
<p>对于变量初始化，C++提供多种方式，较为复杂，在使用中很容易给开发者造成很大困惑；</p>
<p>C++11中的统一列表初始化（std::initializer_list<T>）方式固然有很多优点，但是仍然有<strong>重载决议</strong>(若变量初始化使用大括号，则C++编译器优先调用统一列表初始化进行初始化)等令人迷惑的问题产生；</p>
<p>所以在开发过程中，开发者需要遵循一种实践规范来指导各种类型变量的初始化，以使得初始化语义明确，简明易懂；</p>
<h2 id="原则">原则</h2>
<p>以下是我们认为理解容易、执行简单的一种初始化的最佳实践原则；当然，可能每一位开发者都有自己认为的最佳实践原则，只要简单易行即可，不必强求，故对于本原则，不喜勿喷；</p>
<p>本原则条目如下：</p>
<ul>
<li>须对所有变量进行初始化，即在使用前不能有未定义的值；</li>
<li>使用语义明确且符合直觉的初始化方式；</li>
<li>根据不同数据类型与给定初始化参数使用不同初始化方式；</li>
</ul>
<h2 id="最佳实践">最佳实践</h2>
<p>综合上述三条原则，结合开发实践，总结了对于不同数据类型初始化的操作性较强的最佳实践，示例代码如下：</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

struct Stru {
    int a;
    string b;
};

class Demo {
public:
    Demo() = default;
    explicit Demo(const int a);
    explicit Demo(const int a, const double b);
    Demo(const Demo&amp; rhs) = default;
    Demo&amp; operator=(const Demo&amp; rh) = default;
    ~Demo() = default;
private:
    int m_a;
    double m_b;
    std::vector&lt;double&gt; m_c;
};


int main()
{
    double a = 2.0;                         // 单个POD类型：拷贝初始化
    struct Stru c = {2， &quot;stringTest&quot;};     // 结构体：列表初始化   
    double b[3] = {1.0, 2.0, 3.0};         // 数组：列表初始化
    
    Demo demo1;                            // 单个类类型（无参数初始化）：默认初始化
    Demo demo2(1, 2,5);                    // 单个类类型（参数化初始化）：实参匹配直接初始化
    
    vector&lt;double&gt; vec = {1.0, 2.0, 3.0};  // 容器序列 ： 列表初始化
    
    return 0;  
}
</code></pre>
<h2 id="结论">结论</h2>
<p>对以上初始化最佳实践总结如下：</p>
<ul>
<li>单个POD类型数据的初始化： 拷贝初始化；</li>
<li>单个类类型数据的无参数与参数化初始化： 默认初始化 or 实参匹配直接初始化；</li>
<li>依次赋值各成员容器[结构体、数组、STL各种容器、可逐个赋值各成员的类、等]序列初始化： 列表初始化；</li>
<li>其他方式尽量不要使用；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++类内初始化]]></title>
        <id>https://wangtongxuewang.github.io/post/clei-nei-chu-shi-hua/</id>
        <link href="https://wangtongxuewang.github.io/post/clei-nei-chu-shi-hua/">
        </link>
        <updated>2021-04-13T00:38:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c类内初始化">C++类内初始化</h1>
<h2 id="引言">引言</h2>
<p>当成员变量参数较多，很可能在构造函数中忘记初始化某些成员变量，当需要访问某些变量时可能会产生意想不到的行为，故需一种简明的方式避免此问题的发生；</p>
<h2 id="类内初始化">类内初始化</h2>
<p>对于上述问题，可使用C++11中特性——类内初始化，防止遗漏某些变量的初始化，示例代码如下：</p>
<pre><code class="language-C++">class Demo {
public:
    Demo() = default;
    Demo(const int a, const double b);
    ~Demo() = default;
    // ...
private:
    int     m_a = 1;
    double  m_b = 2.0;
    X*      m_c = nullptr;
    std::vector&lt;int&gt; m_d = {1, 2, 3};
};

Demo::Demo(const int a, const double b) : m_a(a), m_b(b)
{
    // do nothing
}

// ...

int main()
{
    Demo demo1;  // 此时各成员变量已经赋上相应初值
    Demo demo2(1, 2.0);

    // do something

    return 0;
}
</code></pre>
<h2 id="结论">结论</h2>
<p>当类中成员变量较多时，可适当使用类内初始化来避免遗漏某些成员变量初始化值；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++中的explicit]]></title>
        <id>https://wangtongxuewang.github.io/post/czhong-de-explicit/</id>
        <link href="https://wangtongxuewang.github.io/post/czhong-de-explicit/">
        </link>
        <updated>2021-04-12T11:33:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c中的explicit">C++中的explicit</h1>
<h2 id="引言">引言</h2>
<p>在C++开发中，常会因为各种原因无意中编写出如下代码：</p>
<pre><code class="language-c++">class Demo {
public:
    Demo() = default;
    Demo(const int a);
    Demo(const double b, const double c=2.5, const double d=3.5);
    ~Demo() = default;
    // ...
private:
    int m_a;
    double m_b;
};

int main()
{
    Demo demo = 10;  // 编译通过，但这不是我们想要的行为
    
    // ...
    return 0;
}
</code></pre>
<p>上述代码编译通过，即编译器允许这种操作，这实际上是调用了构造函数 Demo(const int a) 进行了隐式转换，但此操作很可能是开发人员不希望发生的，程序有可能会在运行中发生意想不到的错误，所以需要一种机制禁止这种隐式转换；</p>
<h2 id="方法">方法</h2>
<p>C++提供了在构造函数中添加 explicit 关键字来防止上述问题的发生，在 Qt 库中，经常可以看到此种习惯，这减少了程序隐患，值得我们学习参考；</p>
<p>上述代码改进后，如下所示：</p>
<pre><code class="language-c++">class Demo {
public:
    Demo() = default;
    explicit Demo(const int a);
    explicit Demo(const double b, const double c=2.5, const double d=3.5);
    ~Demo() = default;
    void update();
    // ...
private:
    int m_a;
    double m_b;
};

int main()
{
    Demo demo = 10;  // 编译不通过，符合我们对程序行为的预期
    
    // ...
    return 0;
}
</code></pre>
<h2 id="结论">结论</h2>
<p>最佳实践：在类构造函数中，只要能使用一个参数的，均加上 explicit 关键字以防止隐式转换；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++类成员函数指针获取]]></title>
        <id>https://wangtongxuewang.github.io/post/clei-cheng-yuan-han-shu-zhi-zhen-huo-qu/</id>
        <link href="https://wangtongxuewang.github.io/post/clei-cheng-yuan-han-shu-zhi-zhen-huo-qu/">
        </link>
        <updated>2021-04-11T03:51:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c类成员函数指针获取">C++类成员函数指针获取</h1>
<p>在C++开发中，我们经常会遇到需要获取类成员函数中的指针，这个是大家都比较熟悉的；</p>
<p>那么如果类成员函数是重载的，应如何获取指定类成员函数指针呢，示例C++代码如下：</p>
<pre><code class="language-c++">class GLWidget {
public:
    void update(int a, int b);
    void updata();
private:
    // ...
};


#include &lt;QObject&gt;
#include &lt;QTimer&gt;

int main()
{
    const int updateMilliSec = 10;
    
    QTimer timer;
    timer.start(updateMilliSec);
    
    GLWidget glWidget;
    
    typedef void (GLWidget::*PtrTypeUpdate1)(int, int);
    using PtrTypeUpdate2 = void (GLWidget::*)(void);
    
    PtrTypeUpdate1 ptrUpdate1 = static_cast&lt;PtrTypeUpdate1&gt;(&amp;GLWidget::update);
    PtrTypeUpdate2 ptrUpdate2 = static_cast&lt;PtrTypeUpdate2&gt;(&amp;GLWidget::update);
    
    QObject::connect(&amp;timer, &amp;QTimer::timeout, &amp;glWidget, ptrUpdate1); 
    
    // ...
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>