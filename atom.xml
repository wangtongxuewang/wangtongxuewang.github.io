<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangtongxuewang.github.io</id>
    <title>王同学的博客</title>
    <updated>2021-06-21T10:52:27.650Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangtongxuewang.github.io"/>
    <link rel="self" href="https://wangtongxuewang.github.io/atom.xml"/>
    <subtitle>coding &amp;&amp; writing</subtitle>
    <logo>https://wangtongxuewang.github.io/images/avatar.png</logo>
    <icon>https://wangtongxuewang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 王同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[C++的值类别]]></title>
        <id>https://wangtongxuewang.github.io/post/cde-zhi-lei-bie/</id>
        <link href="https://wangtongxuewang.github.io/post/cde-zhi-lei-bie/">
        </link>
        <updated>2021-06-21T10:40:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c的值类别">C++的值类别</h1>
<h2 id="值类别">值类别</h2>
<p>C++表达式有两种属性：类型(type)和值类别(value category)。其中类型主要区别值的大小与解读方式，此属性是大家熟知的，故不赘述，以下内容主要阐述值类别。</p>
<p>每个表达式只属于三种值类别中的一种，纯右值(prvalue)、亡值(xvalue)、左值(lvalue)；纯右值和亡值统称为右值(rvalue)，亡值和左值统称为泛左值(glvalue)；以上对于值类别的表述可能难以理解，以下进行详细解释；</p>
<p>在C++11中，值类别主要用以表达区别表达式<strong>是否拥有身份</strong>以及<strong>是否可被移动</strong>：</p>
<ul>
<li>拥有身份(泛左值)：可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的地址；</li>
<li>可被移动(右值)：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式；</li>
</ul>
<p>即拥有身份的表达式被称作泛左值表达式，可被移动的表达式被称作右值表达式，同时又有：</p>
<ul>
<li>拥有身份 且 不可被移动 的表达式被称作*左值 (lvalue)*表达式 [只属于泛左值表达式]；</li>
<li>拥有身份 且 可被移动 的表达式被称作*亡值 (xvalue)*表达式 [既属于泛左值表达式，又属于右值表达式]；</li>
<li>不拥有身份 且 可被移动 的表达式被称作*纯右值 (prvalue)*表达式 [只属于右值表达式]；</li>
<li>不拥有身份 且 不可被移动 的表达式无法使用；</li>
</ul>
<p>使用树状图直观展示如下：</p>
<pre><code class="language-mermaid">graph TB
A(表达式)
B(泛左值)
C(右值)
D(左值)
E(亡值)
F(纯右值)

A--&gt;B
A--&gt;C
B--&gt;D
B--&gt;E
C--&gt;E
C--&gt;F
</code></pre>
<h2 id="移动语义">移动语义</h2>
<p>在C++11中引入新的值类别的概念，其中重要目的就是应用移动语义，以此减少很多不必要的拷贝，从而大幅度提升性能；</p>
<p>实现“移动”主要是依靠std::move(), 其主要功能其实并不是真正的移动，而是将表达式值类别强制转换为右值型别，其具体实现在C++STL中如下所示 [ 代码片段来自 MinGW7.3.0 中的 move.h ]</p>
<pre><code class="language-c++">/**
  *  @brief  Convert a value to an rvalue.
  *  @param  __t  A thing of arbitrary type.
  *  @return The parameter cast to an rvalue-reference to allow moving it.
  */
template&lt;typename _Tp&gt;
constexpr typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;
move(_Tp&amp;&amp; __t) noexcept
{ 
    return static_cast&lt;typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(__t); 
}
</code></pre>
<h2 id="应用举例">应用举例</h2>
<p>下述例子并不能体现 std::move() 的优点，只是作为一个简单例子进行说明：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;memory&gt;

using std::cout;
using std::endl;
using std::unique_ptr;

class Demo {
public:
    Demo() = default;
    Demo(const Demo&amp; rhs) = default;
    Demo(Demo&amp;&amp; rhs) = default;
    Demo&amp; operator=(const Demo&amp; rhs) = default;
    Demo&amp; operator=(Demo&amp;&amp; rhs) = default;
    ~Demo() = default;
private:
    int m_a = 1;
    // ...
};


int main()
{
    unique_ptr&lt;Demo&gt; ptrDemo = std::make_unique&lt;Demo&gt;();

    cout &lt;&lt; &quot;ptrDemo : &quot; &lt;&lt; ptrDemo.get() &lt;&lt; endl;

    // unique_ptr不支持拷贝构造与拷贝赋值操作
    unique_ptr&lt;Demo&gt; ptrDemo2 = std::move(ptrDemo);
    assert(ptrDemo == nullptr);

    cout &lt;&lt; &quot;ptrDemo : &quot; &lt;&lt; ptrDemo.get() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptrDemo2 : &quot; &lt;&lt; ptrDemo2.get() &lt;&lt; endl;

    // ...

    return 0;
}

</code></pre>
<p>终端输出：</p>
<pre><code class="language-c++">// console output : 
ptrDemo : 0x1304b68
ptrDemo : 0
ptrDemo2 : 0x1304b68
</code></pre>
<h2 id="参考">参考</h2>
<p><a href="https://www.cnblogs.com/zhao-zongsheng/p/value_categories_and_move_semantics.html">C++11的value category(值类别)以及move semantics(移动语义)</a></p>
<p><a href="https://zh.cppreference.com/w/cpp/language/value_category">cppreference - value_category</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[运行时类型识别]]></title>
        <id>https://wangtongxuewang.github.io/post/yun-xing-shi-lei-xing-shi-bie/</id>
        <link href="https://wangtongxuewang.github.io/post/yun-xing-shi-lei-xing-shi-bie/">
        </link>
        <updated>2021-06-13T09:26:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="运行时类型识别">运行时类型识别</h1>
<p>运行时类型识别(RTTI)主要作用是获得指针及引用变量的实际类型, 其主要操作有两种, 分别是 获取实际类型 与 安全类型转换；</p>
<h2 id="获取实际类型">获取实际类型</h2>
<p>获取实际类型主要依靠:  typeid 关键字 与 type_info 类, 示例代码如下:</p>
<p>类代码:</p>
<pre><code class="language-c++">// demo.h
class Demo {
public:
    Demo() = default;
    virtual ~Demo() = default;

    virtual void disp()  {cout &lt;&lt; &quot;Demo&quot; &lt;&lt; endl;}

    inline double dispA() {return m_a;}
private:
    double m_a = 10.0;
};


class DemoDerived : public Demo {
public:
    DemoDerived() = default;
    ~DemoDerived() = default;

    virtual void disp() override {cout &lt;&lt; &quot;DemoDeriv&quot; &lt;&lt; endl;}

    inline double dispB() {return m_b;}
private:
    double m_b = 8.0;
};
</code></pre>
<p>主函数:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

#include &quot;demo.h&quot;

using std::cout;
using std::endl;
using std::type_info;


int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new DemoDerived();

    const type_info&amp; type1 = typeid (*demo1);
    const type_info&amp; type2 = typeid (*demo2);

    cout &lt;&lt; type1.name() &lt;&lt; endl;
    cout &lt;&lt; type2.name() &lt;&lt; endl;

    delete demo1;
    delete demo2;

    return 0;
}
</code></pre>
<p>终端输出:</p>
<pre><code class="language-c++">// console output : 
4Demo
11DemoDerived
</code></pre>
<p>不同编译器可能输出略微不同, 但是仍可看到两个指针所指向的实际类型分别为 Demo 与 DemoDerived, 其中数字表示类型名称的字符长度；</p>
<h2 id="安全类型转换">安全类型转换</h2>
<p>在基类与继承类之间进行安全类型转换主要依靠 dynamic_cast&lt;&gt;() 操作, 示例代码如下；</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

#include &quot;demo.h&quot;

using std::cout;
using std::endl;
using std::type_info;


int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new DemoDerived();

    DemoDerived* demoCast1 = dynamic_cast&lt;DemoDerived*&gt;(demo1);
    DemoDerived* demoCast2 = dynamic_cast&lt;DemoDerived*&gt;(demo2);

    cout &lt;&lt; &quot;demoCast1 addr = &quot; &lt;&lt; demoCast1 &lt;&lt; endl;
    cout &lt;&lt; &quot;demoCast2 addr = &quot; &lt;&lt; demoCast2 &lt;&lt; endl;

    delete demo1;
    delete demo2;

    return 0;
}
</code></pre>
<p>上述代码终端输出:</p>
<pre><code class="language-c++">// console output : 
demoCast1 addr = 0
demoCast2 addr = 0x55555556aed0
</code></pre>
<p>其中, demo2 的实际类型是 DemoDerived, 所以动态类型转换成功, demoCast2是有效地址；demo1 的实际类型 Demo, 所以动态类型转换失败, demoCast1 地址为 0, 是无效地址, 表示了这种转换是不正确的, 这正是动态类型转换的安全性所在；</p>
<p>而静态类型转换 static_cast 不会检查类型转换之间的安全性, 反而会引起一些潜在危险,且难以排查, 示例代码如下:</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;typeinfo&gt;

#include &quot;demo.h&quot;

using std::cout;
using std::endl;
using std::type_info;

int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new DemoDerived();

    DemoDerived* ptrDemoError = static_cast&lt;DemoDerived *&gt;(demo1);

    cout &lt;&lt; &quot;ptrDemoError addr = &quot; &lt;&lt; ptrDemoError &lt;&lt; endl;

    cout &lt;&lt; ptrDemoError-&gt;dispA() &lt;&lt; endl;
    cout &lt;&lt; ptrDemoError-&gt;dispB() &lt;&lt; endl;

    delete demo1;
    delete demo2;

    return 0;
}
</code></pre>
<p>上述代码终端输出为:</p>
<pre><code class="language-c++">// console output : 
ptrDemoError addr = 0x55555556aeb0
10
0
</code></pre>
<p>虽然上述代码中的类型转换是不正确的, 但是静态类型转换仍然能够获得demo1的地址, 而后其错误地使用了DemoDerived中的dispB(), 给出了错误的结果；这种错误排查难度远远大于程序意外终止等明显的问题；</p>
<p>所以, 在基类与继承类之间的转换中尽量只使用 dynamic_cast, 不要使用C风格的强制类型转换 与 static_cast 等不安全的类型转换, 除非自己明确知道这种类型的转换一定是正确的, 否则产生错误可能非常难以排查；</p>
<h2 id="总结">总结</h2>
<p>运行时类型识别RTTI虽然会降低程序性能, 但是适当使用提升了程序的安全性, 对编码起到事半功倍的效果；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于 std::unique_ptr 的思考]]></title>
        <id>https://wangtongxuewang.github.io/post/guan-yu-stdunique_ptr-de-si-kao/</id>
        <link href="https://wangtongxuewang.github.io/post/guan-yu-stdunique_ptr-de-si-kao/">
        </link>
        <updated>2021-05-31T12:11:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于-stdunique_ptr-的思考">关于 std::unique_ptr 的思考</h1>
<p>std::unique_ptr 表示独占所有权的智能指针，正常情况下，此智能指针管理内存的获取与释放，而普通指针仅负责使用内存；</p>
<h2 id="禁止拷贝">禁止拷贝</h2>
<p>由于 std::unique_ptr 表示独占的含义，所以其是不支持拷贝的，在C++标准库中，unique_ptr 禁止拷贝的实现如下 [ 代码片段来自 MinGW5.3.0 中的 unique_ptr.h ]：</p>
<pre><code class="language-c++">template &lt;typename _Tp, typename _Dp = default_delete&lt;_Tp&gt;&gt;
class unique_ptr {
public:
    // ...
    // Disable copy from lvalue.
    unique_ptr(const unique_ptr&amp;) = delete;
    unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;
    // ...
};
</code></pre>
<p>由代码可知，禁止拷贝的实现中采用了C++11的 delete 关键字；而在C++11之前，若要实现禁止拷贝的功能，传统方法是将拷贝构造与赋值运算符私有化，这样是非常不直观的，示例代码如下：</p>
<pre><code class="language-C++">// C++98/03风格的禁止拷贝实现方式
class Demo {
public:
    Demo();
    // ...
private:
    Demo(const Demo&amp; rhs);
    Demo&amp; operator=(const Demo&amp; rhs);
    // ...
}
</code></pre>
<h2 id="函数返回">函数返回</h2>
<p>在C++标准中，std::unique_ptr 是支持函数返回的，最为典型的就是 std::make_unique，其实现代码如下 [ 代码片段来自 MinGW5.3.0 中的 unique_ptr.h ]：</p>
<pre><code class="language-c++">/// std::make_unique for single objects
template&lt;typename _Tp, typename... _Args&gt;
inline typename _MakeUniq&lt;_Tp&gt;::__single_object
make_unique(_Args&amp;&amp;... __args)
{
    return unique_ptr&lt;_Tp&gt;(new _Tp(std::forward&lt;_Args&gt;(__args)...)); 
}
</code></pre>
<p>既然 std::unique_ptr 不支持拷贝，那么为什么其可以进行函数返回呢？这似乎与不支持拷贝是矛盾的；</p>
<p>我们知道，在函数返回中，返回值优化RVO(其在C++17中进入标准)可以让对象直接在函数调用处生成， 而不产生多余的临时对象，从而绕过拷贝/移动构造操作；</p>
<p>因此，std::unique_ptr 的能够函数返回的重要机制是返回值优化RVO绕过了拷贝/移动构造，使其能够函数返回；</p>
<h2 id="开发启示">开发启示</h2>
<p>如上所述，C++标准库在实现中大量应用了C++11/14/17等现代特性，如  =delete，RVO，等；</p>
<p>所以，在开发实践中，我们亦应编写现代C++风格的代码，与时俱进，才能让程序更优雅，更具维护性；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++复制省略]]></title>
        <id>https://wangtongxuewang.github.io/post/cfu-zhi-sheng-lue/</id>
        <link href="https://wangtongxuewang.github.io/post/cfu-zhi-sheng-lue/">
        </link>
        <updated>2021-05-17T12:45:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c-复制省略">C++ 复制省略</h1>
<h2 id="代码示例">代码示例</h2>
<p>在C++中，若要在函数中传递一个占用较多空间的对象到函数体外，一般做法是在函数体外定义变量，并传递指针或引用到函数中，示例代码如下：</p>
<pre><code class="language-c++">// demo.h
class Demo {
public:
    Demo() {std::cout &lt;&lt; &quot;Demo()&quot; &lt;&lt; std::endl;}
    Demo(const Demo&amp; rhs) {std::cout &lt;&lt; &quot;Demo(const Demo&amp; rhs)&quot; &lt;&lt; std::endl;}
    Demo&amp; operator=(const Demo&amp; rhs) {std::cout &lt;&lt; &quot;Demo&amp; operator=(const Demo&amp; rhs)&quot; &lt;&lt; std::endl;}
    Demo(Demo&amp;&amp; rhs) {std::cout &lt;&lt; &quot;Demo(Demo&amp;&amp; rhs)&quot; &lt;&lt; std::endl;}
    Demo&amp; operator=(Demo&amp;&amp; rhs) {std::cout &lt;&lt; &quot;Demo&amp; operator=(Demo&amp;&amp; rhs)&quot; &lt;&lt; std::endl;}
    ~Demo() {std::cout &lt;&lt; &quot;~Demo()&quot; &lt;&lt; std::endl;}
    
    void update();

private:
    int m_a = 10;
    std::vector&lt;double&gt; m_x = {1.2, 2.4};
};
</code></pre>
<pre><code class="language-c++">#include &quot;demo.h&quot;

void func(Demo&amp; demo)
{
    demo.update();
    // do other things to demo.
}

int main() 
{
    Demo demo;
    func(demo);
    
    // ...
    
    return 0;
}
</code></pre>
<p>上述方法无疑是正确的，且能保证性能，但是较为繁琐，而且存在一些潜在隐患；其实，在函数中直接返回一个对象更能反映上述代码的语义，同时更简洁优雅，示例代码如下：</p>
<pre><code class="language-c++">#include &quot;demo.h&quot;

Demo func()
{
    Demo demo
        
    demo.update(a);
    // do other things to demo.
    
    return demo;
}

int main() 
{
    Demo demo = func();
    
    // ...
    
    return 0;
}
</code></pre>
<p>然而由于C++的值语义原因，在第二种方法中，当在函数中返回一个对象时，产生了多余的复制构造与析构操作，代价比较昂贵，所以要想性能优先，那么使用第一种方法更好；</p>
<p>但是，当我们将第二种方法的代码进行编译时，却意外地发现程序只进行了一次构造与析构，和第一种方法性能是一致的，终端输出如下：</p>
<pre><code class="language-c++">// console : 
Demo()
~Demo()
</code></pre>
<p>上述令我们感到惊讶的现象背后就是：编译器的<strong>复制省略(copy-elison)/返回值优化(rvo/nrvo)技术</strong>，此技术已经是C++标准(C++17)的一部分，所以此代码的性能在任何主流编译器的默认选项中都能得到保证；</p>
<p>若想要关闭此功能，以观察编译器原始的表现，可在CMakeLists.txt中进行如下设置：</p>
<pre><code>set(CMAKE_C_FLAGS   &quot;-O0 -Wall -fno-elide-constructors&quot;)
set(CMAKE_CXX_FLAGS &quot;-O0 -Wall -fno-elide-constructors&quot;)
</code></pre>
<p>重新编译后，终端输出如下：</p>
<pre><code class="language-c++">// console : 
Demo()
Demo(Demo&amp;&amp; rhs)
~Demo()
Demo(Demo&amp;&amp; rhs)
~Demo()
~Demo()
</code></pre>
<p>上述结果符合我们预期，产生了两次额外移动构造与析构操作，第一次是函数返回一个对象到临时空间中，另一次是临时对象赋值给目标变量；</p>
<h2 id="最佳实践">最佳实践</h2>
<p>现代C++推荐我们在函数中直接返回一个对象，这可让代码更为简洁，而且其性能由C++标准保证，所以在编写新代码时，尽量使用现代C++推荐的方式；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++智能指针]]></title>
        <id>https://wangtongxuewang.github.io/post/zhi-neng-zhi-zhen-stdunique_ptr/</id>
        <link href="https://wangtongxuewang.github.io/post/zhi-neng-zhi-zhen-stdunique_ptr/">
        </link>
        <updated>2021-05-10T11:32:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c智能指针">C++智能指针</h1>
<h2 id="stdunique_ptr">std::unique_ptr</h2>
<p>C++11提供了三种智能指针, 分别为: shared_ptr, weak_ptr 与 unique_ptr, 以方便内存管理，避免仅使用裸指针可能产生的隐患;<br>
在开发实践中, 为明确内存资源所有权, 我们推荐多使用 unique_ptr , 其他两个智能指针尽量少用, 可将 std::unique_ptr 与裸指针搭配使用, 其中 std::unique_ptr 负责内存的管理, 而裸指针仅负责内存的使用, 这样所有权明确, 减少了问题发生的可能性;<br>
同时, std::unique_ptr 体现了C++RAII的思想精髓，实现了资源的自动管理, 其思想值得在开发实践中学习借鉴;</p>
<h2 id="示例代码">示例代码</h2>
<p>关于 C++11/14 中智能指针使用对于代码的改善如下所示:</p>
<pre><code class="language-c++">// C++98/03 风格
class Demo {
public:
    Demo() {
        m_mem = new Mem();
    }
    ~Demo() {
        // 很有可能忘记此步骤
        if (m_mem) {
            delete m_mem;
        }
    }
    // ...
private:
    Mem* m_mem;
    // ...
};


int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new Demo();
    std::vector&lt;Demo*&gt; vec;
    vec.push_back(demo1);
    vec.push_back(demo2);
    
    // ...
    // 很有可能忘记此步骤
    for (Demo* ptrDemo : vec) {
        delete ptrDemo;
    }
    
    return 0;
}
</code></pre>
<pre><code class="language-c++">// C++11/14 风格
class Demo {
public:
    Demo() {
        m_mem = std::make_unique&lt;Mem&gt;();
    }
    ~Demo() {
        // 内存由 unique_ptr 自动管理, 无需开发者手动释放
        // do other things
    }
    // ...
private:
    std::unique_ptr&lt;Mem&gt; m_mem;
    // ...
};


int main()
{
    std::unique_ptr&lt;Demo&gt; demo1 = std::make_unique&lt;Demo&gt;();
    std::unique_ptr&lt;Demo&gt; demo2 = std::make_unique&lt;Demo&gt;();
    std::vector&lt;std::unique_ptr&lt;Demo&gt;&gt; vec;
    vec.push_back(std::move(demo1));
    vec.push_back(std::move(demo2);

    assert(demo1 == nullptr);
    assert(demo2 == nullptr);
    
    // ...
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++继承与虚函数]]></title>
        <id>https://wangtongxuewang.github.io/post/cji-cheng-yu-xu-han-shu/</id>
        <link href="https://wangtongxuewang.github.io/post/cji-cheng-yu-xu-han-shu/">
        </link>
        <updated>2021-05-02T14:32:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c继承与虚函数">C++继承与虚函数</h1>
<p>在面向对象编程过程中，为实现多态，常用基类指针指向派生类对象操作以动态绑定；<br>
此时继承体系中，基类应采用虚析构函数( virtual ~Demo() )来防止派生类内存泄漏；</p>
<h1 id="示例代码">示例代码</h1>
<p>示例代码如下：</p>
<pre><code class="language-C++">class Base {
public:
    virtual ~Base() {
        cout &lt;&lt; &quot;~Base()&quot; &lt;&lt; endl;
    }
    virtual void doSth();
};

class Derived1 : public Base {
public:
    ~Derived1() {
        cout &lt;&lt; &quot;~Derived1()&quot; &lt;&lt; endl;
    }
    virtual void doSth() override;
};

class DerivedFromDerived1 : public Derived1 {
public:
    ~DerivedFromDerived1() {
        cout &lt;&lt; &quot;~DerivedFromDerived1()&quot; &lt;&lt; endl;
    }
};

class Derived2 : public Base {
public:
    ~Derived2() {
        cout &lt;&lt; &quot;~Derived2()&quot; &lt;&lt; endl;
    }
    virtual void doSth() override;
};


using namespace std;

int main() 
{
    vector&lt;Base*&gt; bases = {
        new Derived1(),
        new Derived2(&quot;Bob&quot;)    
    };
    
    for (const Base* aBase : bases) {
        aBase-&gt;doSth();
    }
    
    for (int i = 0; i &lt; bases.size(); ++i) {
        delete base[i];    
    }
    
    
    Base* base2 = new DerivedFromDerived1();
    delete base2;
    
    return 0;
}
</code></pre>
<h1 id="良好习惯">良好习惯</h1>
<p>在开发实践中，我们总结了如下良好习惯以减少代码中的在继承与虚函数方面的隐患：</p>
<ul>
<li>若类中没有继承关系，禁止随意加上虚函数 virtual 声明；</li>
<li>当类含有继承时，基类析构函数中加上 virtual 关键字声明；</li>
<li>继承体系中基类与子类的虚函数均加上 virtual 声明；</li>
<li>继承体系中使用C++11中的 override、final、delete、default 等关键字；</li>
<li>避免多继承，避免三层以上继承；</li>
<li>使用组合代替继承；</li>
<li>若无法避免继承，则要事先设计良好的继承体系(如严格树形结构)；</li>
</ul>
<p>上述条目仅供参考，也许有的并不适合某些开发场景，不喜勿喷；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++函数传参方式]]></title>
        <id>https://wangtongxuewang.github.io/post/chan-shu-chuan-can-fang-shi/</id>
        <link href="https://wangtongxuewang.github.io/post/chan-shu-chuan-can-fang-shi/">
        </link>
        <updated>2021-04-25T04:13:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c函数传参方式">C++函数传参方式</h1>
<h2 id="引言">引言</h2>
<p>C++函数传参方式有很多种选择，可以传值、传指针、传引用、返回值等，故需要一种内部规范让函数参数传递简明易懂，同时兼顾性能；</p>
<h2 id="代码示例">代码示例</h2>
<p>以下代码使用了结构化绑定，需要编译器支持C++17；</p>
<pre><code class="language-c++">#include &lt;tuple&gt;

class CDemo1 {
    // ...
};

class CDemo2 {
    // ..
};

// 函数传参方式示例
std::tuple&lt;double, std::string&gt; testFunc(const int n, 
                                         const std::vector&lt;double&gt;&amp; x,
                                         CDemo1&amp; out1,
                                         CDemo2* out2 = nullptr)
{
    // do something
}

int main()
{
    const int n = 10;
    const std::vector&lt;double&gt; x = {1.1, 2.2, 3.3};
    CDemo1 d1;
    CDemo2 d2;
    auto [y, errInfo] = testFunc(n, x, d1, &amp;d2);
    
    // ...
    
    return 0;
}
</code></pre>
<h2 id="结论">结论</h2>
<p>通过上述代码示例，可总结函数传参中传值、传引用、传指针、函数返回值的的 <strong>最佳实践</strong>：</p>
<h3 id="函数入参">函数入参</h3>
<p>POD类型使用常值（如  const double x）；</p>
<p>类类型使用常引用（如  const T&amp; x）；</p>
<h3 id="函数出参">函数出参</h3>
<p>若有可能，优先使用函数返回值，尽量不要使用函数出参，以增强可读性；</p>
<p>若需要使用出参，优先使用 T&amp; ；</p>
<p>在出参中，若可能为空（如 有默认参数 = nullptr）或者其指向可能变化，才使用 T* ；</p>
<h3 id="函数返回值">函数返回值</h3>
<p>若是新产生的变量，则返回 单个/多个 值（类类型同样可以返回值，只要保证返回值优化发生，则性能与出参是一样的）；</p>
<p>若是修改函数体之外的变量，可返回比本函数生命周期更长变量的引用/指针；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++函数对象]]></title>
        <id>https://wangtongxuewang.github.io/post/chan-shu-dui-xiang/</id>
        <link href="https://wangtongxuewang.github.io/post/chan-shu-dui-xiang/">
        </link>
        <updated>2021-04-16T06:24:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c函数对象">C++函数对象</h1>
<h2 id="引言">引言</h2>
<p>在实际开发中我们常常希望函数定义与使用可以像变量一样方便，如：可以在一个函数作用域内临时定义，能够方便的当做函数参数进行传递等，而函数对象正是实现这类功能的理想方法；</p>
<p>概念：重载了 operator() 的类对象称为函数对象。当该对象调用 operator() 时，方式、效果同普通函数调用，故名函数对象，示例如下：</p>
<pre><code class="language-c++">class Demo {
public:
    // ...
    void operator() (void) {
        std::cout &lt;&lt; &quot;call operator() ()&quot; &lt;&lt; std::endl;
    }
    // ...
};
</code></pre>
<h2 id="lambda与stdfunction">lambda与std::function</h2>
<p>很多时候我们并不需要自己特地定义一个类并重载 operator() 这样复杂的操作，C++已经为我们提供了实现此功能的基础设施：lambda与std::function，以方便我们使用，示例代码如下：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{    
    std::function&lt;int(const int, const int)&gt; sum = [](const int a, const int b) -&gt; int {
        return a + b; 
    };
    
    auto dot = [](const int a, const int b) -&gt; int { return a*b; };
        
    int sumRes = sum(1, 2);
    int dotRes = dot(1, 2);
    
    std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sumRes &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;dot = &quot; &lt;&lt; dotRes &lt;&lt; std::endl;  
    
    std::vector&lt;int&gt; vec = {3, 1, 4};
    std::for_each(vec.cbegin(), vec.cend(), [](const int n) -&gt; void { 
        std::cout &lt;&lt; &quot;vec_i&quot; &lt;&lt; n &lt;&lt; std::endl; 
    });
}
</code></pre>
<h2 id="适用场景">适用场景</h2>
<p>lambda与std::function适用场景：</p>
<ul>
<li>在函数中定义一个临时函数，就像定义一个变量一样方便；</li>
<li>将函数对象作为参数传入另一个函数中，省去了传入函数指针的繁琐操作；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++STL迭代器]]></title>
        <id>https://wangtongxuewang.github.io/post/cstl-die-dai-qi/</id>
        <link href="https://wangtongxuewang.github.io/post/cstl-die-dai-qi/">
        </link>
        <updated>2021-04-15T01:30:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cstl迭代器">C++STL迭代器</h1>
<p>迭代器是开发中操作容器的常用工具，大部分迭代器操作在容器类成员函数中可直接使用；<br>
但是有一些操作直接使用容器成员函数中的方法可能并不方便，而C++STL中提供的迭代器辅助函数可简洁实现这些操作；<br>
故以下介绍C++STL中迭代器辅助函数，其与容器中成员函数迭代器相关方法结合使用，可有事半功倍的效果；<br>
其中有四个迭代器辅助函数最为常用，示例代码如下：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; vec = {3, 1, 4};
    std::vector&lt;int&gt;::iterator it = vec.begin();

    auto itBeg = std::begin(vec);    // 推荐使用容器类的成员函数
    auto itEnd = std::end(vec);    // 推荐使用容器类的成员函数

    // 以下是迭代器辅助函数最为常用的四种操作
    std::advance(it, 1);    // 跳转
    auto prev_it = std::prev(it);    // 上一个
    auto next_it = std::next(it);    // 下一个
    int dis = std::distance(prev_it, next_it);    // 两个游标之间距离
    
    std::cout &lt;&lt; &quot;*it = &quot; &lt;&lt; *it &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;dis = &quot; &lt;&lt; dis &lt;&lt; std::endl;

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++初始化最佳实践]]></title>
        <id>https://wangtongxuewang.github.io/post/cchu-shi-hua-zui-jia-shi-jian/</id>
        <link href="https://wangtongxuewang.github.io/post/cchu-shi-hua-zui-jia-shi-jian/">
        </link>
        <updated>2021-04-14T05:10:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c初始化最佳实践">C++初始化最佳实践</h1>
<h2 id="引言">引言</h2>
<p>对于变量初始化，C++提供多种方式，较为复杂，在使用中很容易给开发者造成很大困惑；</p>
<p>C++11中的统一列表初始化（std::initializer_list<T>）方式固然有很多优点，但是仍然有<strong>重载决议</strong>(若变量初始化使用大括号，则C++编译器优先调用统一列表初始化进行初始化)等令人迷惑的问题产生；</p>
<p>所以在开发过程中，开发者需要遵循一种实践规范来指导各种类型变量的初始化，以使得初始化语义明确，简明易懂；</p>
<h2 id="原则">原则</h2>
<p>以下是我们认为理解容易、执行简单的一种初始化的最佳实践原则；当然，可能每一位开发者都有自己认为的最佳实践原则，只要简单易行即可，不必强求，故对于本原则，不喜勿喷；</p>
<p>本原则条目如下：</p>
<ul>
<li>须对所有变量进行初始化，即在使用前不能有未定义的值；</li>
<li>使用语义明确且符合直觉的初始化方式；</li>
<li>根据不同数据类型与给定初始化参数使用不同初始化方式；</li>
</ul>
<h2 id="最佳实践">最佳实践</h2>
<p>综合上述三条原则，结合开发实践，总结了对于不同数据类型初始化的操作性较强的最佳实践，示例代码如下：</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

struct Stru {
    int a;
    string b;
};

class Demo {
public:
    Demo() = default;
    explicit Demo(const int a);
    explicit Demo(const int a, const double b);
    Demo(const Demo&amp; rhs) = default;
    Demo&amp; operator=(const Demo&amp; rh) = default;
    ~Demo() = default;
private:
    int m_a;
    double m_b;
    std::vector&lt;double&gt; m_c;
};


int main()
{
    double a = 2.0;                         // 单个POD类型：拷贝初始化
    struct Stru c = {2， &quot;stringTest&quot;};     // 结构体：列表初始化   
    double b[3] = {1.0, 2.0, 3.0};         // 数组：列表初始化
    
    Demo demo1;                            // 单个类类型（无参数初始化）：默认初始化
    Demo demo2(1, 2,5);                    // 单个类类型（参数化初始化）：实参匹配直接初始化
    
    vector&lt;double&gt; vec = {1.0, 2.0, 3.0};  // 容器序列 ： 列表初始化
    
    return 0;  
}
</code></pre>
<h2 id="结论">结论</h2>
<p>对以上初始化最佳实践总结如下：</p>
<ul>
<li>单个POD类型数据的初始化： 拷贝初始化；</li>
<li>单个类类型数据的无参数与参数化初始化： 默认初始化 or 实参匹配直接初始化；</li>
<li>依次赋值各成员容器[结构体、数组、STL各种容器、可逐个赋值各成员的类、等]序列初始化： 列表初始化；</li>
<li>其他方式尽量不要使用；</li>
</ul>
]]></content>
    </entry>
</feed>