<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wangtongxuewang.github.io</id>
    <title>王同学的博客</title>
    <updated>2021-05-17T12:59:33.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wangtongxuewang.github.io"/>
    <link rel="self" href="https://wangtongxuewang.github.io/atom.xml"/>
    <subtitle>&lt;font size=&quot;10&quot;&gt;sharing&lt;/font&gt;</subtitle>
    <logo>https://wangtongxuewang.github.io/images/avatar.png</logo>
    <icon>https://wangtongxuewang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 王同学的博客</rights>
    <entry>
        <title type="html"><![CDATA[C++复制省略]]></title>
        <id>https://wangtongxuewang.github.io/post/cfu-zhi-sheng-lue/</id>
        <link href="https://wangtongxuewang.github.io/post/cfu-zhi-sheng-lue/">
        </link>
        <updated>2021-05-17T12:45:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c-复制省略">C++ 复制省略</h1>
<h2 id="代码示例">代码示例</h2>
<p>在C++中，若要在函数中传递一个占用较多空间的对象到函数体外，一般做法是在函数体外定义变量，并传递指针或引用到函数中，示例代码如下：</p>
<pre><code class="language-c++">// demo.h
class Demo {
public:
    Demo() {std::cout &lt;&lt; &quot;Demo()&quot; &lt;&lt; std::endl;}
    Demo(const Demo&amp; rhs) {std::cout &lt;&lt; &quot;Demo(const Demo&amp; rhs)&quot; &lt;&lt; std::endl;}
    Demo&amp; operator=(const Demo&amp; rhs) {std::cout &lt;&lt; &quot;Demo&amp; operator=(const Demo&amp; rhs)&quot; &lt;&lt; std::endl;}
    Demo(Demo&amp;&amp; rhs) {std::cout &lt;&lt; &quot;Demo(Demo&amp;&amp; rhs)&quot; &lt;&lt; std::endl;}
    Demo&amp; operator=(Demo&amp;&amp; rhs) {std::cout &lt;&lt; &quot;Demo&amp; operator=(Demo&amp;&amp; rhs)&quot; &lt;&lt; std::endl;}
    ~Demo() {std::cout &lt;&lt; &quot;~Demo()&quot; &lt;&lt; std::endl;}
    
    void update();

private:
    int m_a = 10;
    std::vector&lt;double&gt; m_x = {1.2, 2.4};
};
</code></pre>
<pre><code class="language-c++">#include &quot;demo.h&quot;

void func(Demo&amp; demo)
{
    demo.update();
    // do other things to demo.
}

int main() 
{
    Demo demo;
    func(demo);
    
    // ...
    
    return 0;
}
</code></pre>
<p>上述方法无疑是正确的，且能保证性能，但是较为繁琐，而且存在一些潜在隐患；其实，在函数中直接返回一个对象更能反映上述代码的语义，同时更简洁优雅，示例代码如下：</p>
<pre><code class="language-c++">#include &quot;demo.h&quot;

Demo func()
{
    Demo demo
        
    demo.update(a);
    // do other things to demo.
    
    return demo;
}

int main() 
{
    Demo demo = func();
    
    // ...
    
    return 0;
}
</code></pre>
<p>然而由于C++的值语义原因，在第二种方法中，当在函数中返回一个对象时，产生了多余的复制构造与析构操作，代价比较昂贵，所以要想性能优先，那么使用第一种方法更好；</p>
<p>但是，当我们将第二种方法的代码进行编译时，却意外地发现程序只进行了一次构造与析构，和第一种方法性能是一致的，终端输出如下：</p>
<pre><code class="language-c++">// console : 
Demo()
~Demo()
</code></pre>
<p>上述令我们感到惊讶的现象背后就是：编译器的<strong>复制省略(copy-elison)/返回值优化(rvo/nrvo)技术</strong>，此技术已经是C++标准(C++17)的一部分，所以此代码的性能在任何主流编译器的默认选项中都能得到保证；</p>
<p>若想要关闭此功能，以观察编译器原始的表现，可在CMakeLists.txt中进行如下设置：</p>
<pre><code>set(CMAKE_C_FLAGS   &quot;-O0 -Wall -fno-elide-constructors&quot;)
set(CMAKE_CXX_FLAGS &quot;-O0 -Wall -fno-elide-constructors&quot;)
</code></pre>
<p>重新编译后，终端输出如下：</p>
<pre><code class="language-c++">// console : 
Demo()
Demo(Demo&amp;&amp; rhs)
~Demo()
Demo(Demo&amp;&amp; rhs)
~Demo()
~Demo()
</code></pre>
<p>上述结果符合我们预期，产生了两次额外移动构造与析构操作，第一次是函数返回一个对象到临时空间中，另一次是临时对象赋值给目标变量；</p>
<h2 id="最佳实践">最佳实践</h2>
<p>现代C++推荐我们在函数中直接返回一个对象，这可让代码更为简洁，而且其性能由C++标准保证，所以在编写新代码时，尽量使用现代C++推荐的方式；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++智能指针]]></title>
        <id>https://wangtongxuewang.github.io/post/zhi-neng-zhi-zhen-stdunique_ptr/</id>
        <link href="https://wangtongxuewang.github.io/post/zhi-neng-zhi-zhen-stdunique_ptr/">
        </link>
        <updated>2021-05-10T11:32:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c智能指针">C++智能指针</h1>
<h2 id="stdunique_ptr">std::unique_ptr</h2>
<p>C++11提供了三种智能指针, 分别为: shared_ptr, weak_ptr 与 unique_ptr, 以方便内存管理，避免仅使用裸指针可能产生的隐患;<br>
在开发实践中, 为明确内存资源所有权, 我们推荐多使用 unique_ptr , 其他两个智能指针尽量少用, 可将 std::unique_ptr 与裸指针搭配使用, 其中 std::unique_ptr 负责内存的管理, 而裸指针仅负责内存的使用, 这样所有权明确, 减少了问题发生的可能性;<br>
同时, std::unique_ptr 体现了C++RAII的思想精髓，实现了资源的自动管理, 其思想值得在开发实践中学习借鉴;</p>
<h2 id="示例代码">示例代码</h2>
<p>关于 C++11/14 中智能指针使用对于代码的改善如下所示:</p>
<pre><code class="language-c++">// C++98/03 风格
class Demo {
public:
    Demo() {
        m_mem = new Mem();
    }
    ~Demo() {
        // 很有可能忘记此步骤
        if (m_mem) {
            delete m_mem;
        }
    }
    // ...
private:
    Mem* m_mem;
    // ...
};


int main()
{
    Demo* demo1 = new Demo();
    Demo* demo2 = new Demo();
    std::vector&lt;Demo*&gt; vec;
    vec.push_back(demo1);
    vec.push_back(demo2);
    
    // ...
    // 很有可能忘记此步骤
    for (Demo* ptrDemo : vec) {
        delete ptrDemo;
    }
    
    return 0;
}
</code></pre>
<pre><code class="language-c++">// C++11/14 风格
class Demo {
public:
    Demo() {
        m_mem = std::make_unique&lt;Mem&gt;();
    }
    ~Demo() {
        // 内存由 unique_ptr 自动管理, 无需开发者手动释放
        // do other things
    }
    // ...
private:
    std::unique_ptr&lt;Mem&gt; m_mem;
    // ...
};


int main()
{
    std::unique_ptr&lt;Demo&gt; demo1 = std::make_unique&lt;Demo&gt;();
    std::unique_ptr&lt;Demo&gt; demo2 = std::make_unique&lt;Demo&gt;();
    std::vector&lt;std::unique_ptr&lt;Demo&gt;&gt; vec;
    vec.push_back(std::move(demo1));
    vec.push_back(std::move(demo2);

    assert(demo1 == nullptr);
    assert(demo2 == nullptr);
    
    // ...
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++继承与虚函数]]></title>
        <id>https://wangtongxuewang.github.io/post/cji-cheng-yu-xu-han-shu/</id>
        <link href="https://wangtongxuewang.github.io/post/cji-cheng-yu-xu-han-shu/">
        </link>
        <updated>2021-05-02T14:32:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c继承与虚函数">C++继承与虚函数</h1>
<p>在面向对象编程过程中，为实现多态，常用基类指针指向派生类对象操作以动态绑定；<br>
此时继承体系中，基类应采用虚析构函数( virtual ~Demo() )来防止派生类内存泄漏；</p>
<h1 id="示例代码">示例代码</h1>
<p>示例代码如下：</p>
<pre><code class="language-C++">class Base {
public:
    virtual ~Base() {
        cout &lt;&lt; &quot;~Base()&quot; &lt;&lt; endl;
    }
    virtual void doSth();
};

class Derived1 : public Base {
public:
    ~Derived1() {
        cout &lt;&lt; &quot;~Derived1()&quot; &lt;&lt; endl;
    }
    virtual void doSth() override;
};

class DerivedFromDerived1 : public Derived1 {
public:
    ~DerivedFromDerived1() {
        cout &lt;&lt; &quot;~DerivedFromDerived1()&quot; &lt;&lt; endl;
    }
};

class Derived2 : public Base {
public:
    ~Derived2() {
        cout &lt;&lt; &quot;~Derived2()&quot; &lt;&lt; endl;
    }
    virtual void doSth() override;
};


using namespace std;

int main() 
{
    vector&lt;Base*&gt; bases = {
        new Derived1(),
        new Derived2(&quot;Bob&quot;)    
    };
    
    for (const Base* aBase : bases) {
        aBase-&gt;doSth();
    }
    
    for (int i = 0; i &lt; bases.size(); ++i) {
        delete base[i];    
    }
    
    
    Base* base2 = new DerivedFromDerived1();
    delete base2;
    
    return 0;
}
</code></pre>
<h1 id="良好习惯">良好习惯</h1>
<p>在开发实践中，我们总结了如下良好习惯以减少代码中的在继承与虚函数方面的隐患：</p>
<ul>
<li>若类中没有继承关系，禁止随意加上虚函数 virtual 声明；</li>
<li>当类含有继承时，基类析构函数中加上 virtual 关键字声明；</li>
<li>继承体系中基类与子类的虚函数均加上 virtual 声明；</li>
<li>继承体系中使用C++11中的 override、final、delete、default 等关键字；</li>
<li>避免多继承，避免三层以上继承；</li>
<li>使用组合代替继承；</li>
<li>若无法避免继承，则要事先设计良好的继承体系(如严格树形结构)；</li>
</ul>
<p>上述条目仅供参考，也许有的并不适合某些开发场景，不喜勿喷；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++函数传参方式]]></title>
        <id>https://wangtongxuewang.github.io/post/chan-shu-chuan-can-fang-shi/</id>
        <link href="https://wangtongxuewang.github.io/post/chan-shu-chuan-can-fang-shi/">
        </link>
        <updated>2021-04-25T04:13:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c函数传参方式">C++函数传参方式</h1>
<h2 id="引言">引言</h2>
<p>C++函数传参方式有很多种选择，可以传值、传指针、传引用、返回值等，故需要一种内部规范让函数参数传递简明易懂，同时兼顾性能；</p>
<h2 id="代码示例">代码示例</h2>
<p>以下代码使用了结构化绑定，需要编译器支持C++17；</p>
<pre><code class="language-c++">#include &lt;tuple&gt;

class CDemo1 {
    // ...
};

class CDemo2 {
    // ..
};

// 函数传参方式示例
std::tuple&lt;double, std::string&gt; testFunc(const int n, 
                                         const std::vector&lt;double&gt;&amp; x,
                                         CDemo1&amp; out1,
                                         CDemo2* out2 = nullptr)
{
    // do something
}

int main()
{
    const int n = 10;
    const std::vector&lt;double&gt; x = {1.1, 2.2, 3.3};
    CDemo1 d1;
    CDemo2 d2;
    auto [y, errInfo] = testFunc(n, x, d1, &amp;d2);
    
    // ...
    
    return 0;
}
</code></pre>
<h2 id="结论">结论</h2>
<p>通过上述代码示例，可总结函数传参中传值、传引用、传指针、函数返回值的的 <strong>最佳实践</strong>：</p>
<h3 id="函数入参">函数入参</h3>
<p>POD类型使用常值（如  const double x）；</p>
<p>类类型使用常引用（如  const T&amp; x）；</p>
<h3 id="函数出参">函数出参</h3>
<p>若有可能，优先使用函数返回值，尽量不要使用函数出参，以增强可读性；</p>
<p>若需要使用出参，优先使用 T&amp; ；</p>
<p>在出参中，若可能为空（如 有默认参数 = nullptr）或者其指向可能变化，才使用 T* ；</p>
<h3 id="函数返回值">函数返回值</h3>
<p>若是新产生的变量，则返回 单个/多个 值（类类型同样可以返回值，只要保证返回值优化发生，则性能与出参是一样的）；</p>
<p>若是修改函数体之外的变量，可返回比本函数生命周期更长变量的引用/指针；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++函数对象]]></title>
        <id>https://wangtongxuewang.github.io/post/chan-shu-dui-xiang/</id>
        <link href="https://wangtongxuewang.github.io/post/chan-shu-dui-xiang/">
        </link>
        <updated>2021-04-16T06:24:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c函数对象">C++函数对象</h1>
<h2 id="引言">引言</h2>
<p>在实际开发中我们常常希望函数定义与使用可以像变量一样方便，如：可以在一个函数作用域内临时定义，能够方便的当做函数参数进行传递等，而函数对象正是实现这类功能的理想方法；</p>
<p>概念：重载了 operator() 的类对象称为函数对象。当该对象调用 operator() 时，方式、效果同普通函数调用，故名函数对象，示例如下：</p>
<pre><code class="language-c++">class Demo {
public:
    // ...
    void operator() (void) {
        std::cout &lt;&lt; &quot;call operator() ()&quot; &lt;&lt; std::endl;
    }
    // ...
};
</code></pre>
<h2 id="lambda与stdfunction">lambda与std::function</h2>
<p>很多时候我们并不需要自己特地定义一个类并重载 operator() 这样复杂的操作，C++已经为我们提供了实现此功能的基础设施：lambda与std::function，以方便我们使用，示例代码如下：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{    
    std::function&lt;int(const int, const int)&gt; sum = [](const int a, const int b) -&gt; int {
        return a + b; 
    };
    
    auto dot = [](const int a, const int b) -&gt; int { return a*b; };
        
    int sumRes = sum(1, 2);
    int dotRes = dot(1, 2);
    
    std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sumRes &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;dot = &quot; &lt;&lt; dotRes &lt;&lt; std::endl;  
    
    std::vector&lt;int&gt; vec = {3, 1, 4};
    std::for_each(vec.cbegin(), vec.cend(), [](const int n) -&gt; void { 
        std::cout &lt;&lt; &quot;vec_i&quot; &lt;&lt; n &lt;&lt; std::endl; 
    });
}
</code></pre>
<h2 id="适用场景">适用场景</h2>
<p>lambda与std::function适用场景：</p>
<ul>
<li>在函数中定义一个临时函数，就像定义一个变量一样方便；</li>
<li>将函数对象作为参数传入另一个函数中，省去了传入函数指针的繁琐操作；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++STL迭代器]]></title>
        <id>https://wangtongxuewang.github.io/post/cstl-die-dai-qi/</id>
        <link href="https://wangtongxuewang.github.io/post/cstl-die-dai-qi/">
        </link>
        <updated>2021-04-15T01:30:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="cstl迭代器">C++STL迭代器</h1>
<p>迭代器是开发中操作容器的常用工具，大部分迭代器操作在容器类成员函数中可直接使用；<br>
但是有一些操作直接使用容器成员函数中的方法可能并不方便，而C++STL中提供的迭代器辅助函数可简洁实现这些操作；<br>
故以下介绍C++STL中迭代器辅助函数，其与容器中成员函数迭代器相关方法结合使用，可有事半功倍的效果；<br>
其中有四个迭代器辅助函数最为常用，示例代码如下：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; vec = {3, 1, 4};
    std::vector&lt;int&gt;::iterator it = vec.begin();

    auto itBeg = std::begin(vec);    // 推荐使用容器类的成员函数
    auto itEnd = std::end(vec);    // 推荐使用容器类的成员函数

    // 以下是迭代器辅助函数最为常用的四种操作
    std::advance(it, 1);    // 跳转
    auto prev_it = std::prev(it);    // 上一个
    auto next_it = std::next(it);    // 下一个
    int dis = std::distance(prev_it, next_it);    // 两个游标之间距离
    
    std::cout &lt;&lt; &quot;*it = &quot; &lt;&lt; *it &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;dis = &quot; &lt;&lt; dis &lt;&lt; std::endl;

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++初始化最佳实践]]></title>
        <id>https://wangtongxuewang.github.io/post/cchu-shi-hua-zui-jia-shi-jian/</id>
        <link href="https://wangtongxuewang.github.io/post/cchu-shi-hua-zui-jia-shi-jian/">
        </link>
        <updated>2021-04-14T05:10:15.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c初始化最佳实践">C++初始化最佳实践</h1>
<h2 id="引言">引言</h2>
<p>对于变量初始化，C++提供多种方式，较为复杂，在使用中很容易给开发者造成很大困惑；</p>
<p>C++11中的统一列表初始化（std::initializer_list<T>）方式固然有很多优点，但是仍然有<strong>重载决议</strong>(若变量初始化使用大括号，则C++编译器优先调用统一列表初始化进行初始化)等令人迷惑的问题产生；</p>
<p>所以在开发过程中，开发者需要遵循一种实践规范来指导各种类型变量的初始化，以使得初始化语义明确，简明易懂；</p>
<h2 id="原则">原则</h2>
<p>以下是我们认为理解容易、执行简单的一种初始化的最佳实践原则；当然，可能每一位开发者都有自己认为的最佳实践原则，只要简单易行即可，不必强求，故对于本原则，不喜勿喷；</p>
<p>本原则条目如下：</p>
<ul>
<li>须对所有变量进行初始化，即在使用前不能有未定义的值；</li>
<li>使用语义明确且符合直觉的初始化方式；</li>
<li>根据不同数据类型与给定初始化参数使用不同初始化方式；</li>
</ul>
<h2 id="最佳实践">最佳实践</h2>
<p>综合上述三条原则，结合开发实践，总结了对于不同数据类型初始化的操作性较强的最佳实践，示例代码如下：</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

struct Stru {
    int a;
    string b;
};

class Demo {
public:
    Demo() = default;
    explicit Demo(const int a);
    explicit Demo(const int a, const double b);
    Demo(const Demo&amp; rhs) = default;
    Demo&amp; operator=(const Demo&amp; rh) = default;
    ~Demo() = default;
private:
    int m_a;
    double m_b;
    std::vector&lt;double&gt; m_c;
};


int main()
{
    double a = 2.0;                         // 单个POD类型：拷贝初始化
    struct Stru c = {2， &quot;stringTest&quot;};     // 结构体：列表初始化   
    double b[3] = {1.0, 2.0, 3.0};         // 数组：列表初始化
    
    Demo demo1;                            // 单个类类型（无参数初始化）：默认初始化
    Demo demo2(1, 2,5);                    // 单个类类型（参数化初始化）：实参匹配直接初始化
    
    vector&lt;double&gt; vec = {1.0, 2.0, 3.0};  // 容器序列 ： 列表初始化
    
    return 0;  
}
</code></pre>
<h2 id="结论">结论</h2>
<p>对以上初始化最佳实践总结如下：</p>
<ul>
<li>单个POD类型数据的初始化： 拷贝初始化；</li>
<li>单个类类型数据的无参数与参数化初始化： 默认初始化 or 实参匹配直接初始化；</li>
<li>依次赋值各成员容器[结构体、数组、STL各种容器、可逐个赋值各成员的类、等]序列初始化： 列表初始化；</li>
<li>其他方式尽量不要使用；</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++类内初始化]]></title>
        <id>https://wangtongxuewang.github.io/post/clei-nei-chu-shi-hua/</id>
        <link href="https://wangtongxuewang.github.io/post/clei-nei-chu-shi-hua/">
        </link>
        <updated>2021-04-13T00:38:07.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c类内初始化">C++类内初始化</h1>
<h2 id="引言">引言</h2>
<p>当成员变量参数较多，很可能在构造函数中忘记初始化某些成员变量，当需要访问某些变量时可能会产生意想不到的行为，故需一种简明的方式避免此问题的发生；</p>
<h2 id="类内初始化">类内初始化</h2>
<p>对于上述问题，可使用C++11中特性——类内初始化，防止遗漏某些变量的初始化，示例代码如下：</p>
<pre><code class="language-C++">class Demo {
public:
    Demo() = default;
    Demo(const int a, const double b);
    ~Demo() = default;
    // ...
private:
    int     m_a = 1;
    double  m_b = 2.0;
    X*      m_c = nullptr;
    std::vector&lt;int&gt; m_d = {1, 2, 3};
};

Demo::Demo(const int a, const double b) : m_a(a), m_b(b)
{
    // do nothing
}

// ...

int main()
{
    Demo demo1;  // 此时各成员变量已经赋上相应初值
    Demo demo2(1, 2.0);

    // do something

    return 0;
}
</code></pre>
<h2 id="结论">结论</h2>
<p>当类中成员变量较多时，可适当使用类内初始化来避免遗漏某些成员变量初始化值；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++中的explicit]]></title>
        <id>https://wangtongxuewang.github.io/post/czhong-de-explicit/</id>
        <link href="https://wangtongxuewang.github.io/post/czhong-de-explicit/">
        </link>
        <updated>2021-04-12T11:33:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c中的explicit">C++中的explicit</h1>
<h2 id="引言">引言</h2>
<p>在C++开发中，常会因为各种原因无意中编写出如下代码：</p>
<pre><code class="language-c++">class Demo {
public:
    Demo() = default;
    Demo(const int a);
    Demo(const double b, const double c=2.5, const double d=3.5);
    ~Demo() = default;
    // ...
private:
    int m_a;
    double m_b;
};

int main()
{
    Demo demo = 10;  // 编译通过，但这不是我们想要的行为
    
    // ...
    return 0;
}
</code></pre>
<p>上述代码编译通过，即编译器允许这种操作，这实际上是调用了构造函数 Demo(const int a) 进行了隐式转换，但此操作很可能是开发人员不希望发生的，程序有可能会在运行中发生意想不到的错误，所以需要一种机制禁止这种隐式转换；</p>
<h2 id="方法">方法</h2>
<p>C++提供了在构造函数中添加 explicit 关键字来防止上述问题的发生，在 Qt 库中，经常可以看到此种习惯，这减少了程序隐患，值得我们学习参考；</p>
<p>上述代码改进后，如下所示：</p>
<pre><code class="language-c++">class Demo {
public:
    Demo() = default;
    explicit Demo(const int a);
    explicit Demo(const double b, const double c=2.5, const double d=3.5);
    ~Demo() = default;
    void update();
    // ...
private:
    int m_a;
    double m_b;
};

int main()
{
    Demo demo = 10;  // 编译不通过，符合我们对程序行为的预期
    
    // ...
    return 0;
}
</code></pre>
<h2 id="结论">结论</h2>
<p>最佳实践：在类构造函数中，只要能使用一个参数的，均加上 explicit 关键字以防止隐式转换；</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++类成员函数指针获取]]></title>
        <id>https://wangtongxuewang.github.io/post/clei-cheng-yuan-han-shu-zhi-zhen-huo-qu/</id>
        <link href="https://wangtongxuewang.github.io/post/clei-cheng-yuan-han-shu-zhi-zhen-huo-qu/">
        </link>
        <updated>2021-04-11T03:51:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="c类成员函数指针获取">C++类成员函数指针获取</h1>
<p>在C++开发中，我们经常会遇到需要获取类成员函数中的指针，这个是大家都比较熟悉的；</p>
<p>那么如果类成员函数是重载的，应如何获取指定类成员函数指针呢，示例C++代码如下：</p>
<pre><code class="language-c++">class GLWidget {
public:
    void update(int a, int b);
    void updata();
private:
    // ...
};


#include &lt;QObject&gt;
#include &lt;QTimer&gt;

int main()
{
    const int updateMilliSec = 10;
    
    QTimer timer;
    timer.start(updateMilliSec);
    
    GLWidget glWidget;
    
    typedef void (GLWidget::*PtrTypeUpdate1)(int, int);
    using PtrTypeUpdate2 = void (GLWidget::*)(void);
    
    PtrTypeUpdate1 ptrUpdate1 = static_cast&lt;PtrTypeUpdate1&gt;(&amp;GLWidget::update);
    PtrTypeUpdate2 ptrUpdate2 = static_cast&lt;PtrTypeUpdate2&gt;(&amp;GLWidget::update);
    
    QObject::connect(&amp;timer, &amp;QTimer::timeout, &amp;glWidget, ptrUpdate1); 
    
    // ...
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>